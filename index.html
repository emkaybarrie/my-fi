<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>myFi - The Badlands</title>
    <!-- <preference name="Orientation" value="landscape" /> -->
    <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
            
        }
    </style>
</head>
<body>

<script type="text/javascript">

    var ratio = Math.max((window.innerWidth * window.devicePixelRatio)/ (window.innerHeight * window.devicePixelRatio), (window.innerHeight * window.devicePixelRatio) / (window.innerWidth * window.devicePixelRatio)) 
    var DEFAULT_HEIGHT = 272 //* window.devicePixelRatio // any height you want
    var DEFAULT_WIDTH = ratio * DEFAULT_HEIGHT// * 2


    var config = {
        type: Phaser.AUTO,

        scale: {

            parent: 'mygame',
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH,
            width:  DEFAULT_WIDTH, //592, //window.innerWidth * window.devicePixelRatio
            height: DEFAULT_HEIGHT //272, //window.innerHeight * window.devicePixelRatio
        },
        input: {
            keyboard: true,
            gamepad: true
        },
        physics:{
            default:'arcade',
            arcade:{
                gravity:{x: 0, y:350},
                debug: 0,
                overlapBias: 20
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };


    var game = new Phaser.Game(config);
    var gameOver = false

    var IS_TOUCH = false


    var width = game.config.width
    var height = game.config.height
    var spotlight
    
    var startPosition 
    var playerPosition 
    
    var playerSpeed 
    var distanceToTravel = 7500
    var distanceTravelled = 0
    
     
    var inBattle = false                                       
    var deathBlows = false
    var parry = false

    var income = 100
    var lifeRegenAllocation = 0.3 // Equates to budget % allocated to needs
    var energyRegenAllocation = 0.5
    var focusRegenAllocation = 0.2
    
    var lifeRegen = lifeRegenAllocation * income
    var energyRegen = energyRegenAllocation * income
    var focusRegen = focusRegenAllocation * income

    var chargePower = 0
    var keyDuration = 0
    var damage = 0

    var maxLife = income * 3
    var startLife = maxLife
    var currentLife 

    var maxEnergy = 100
    var currentEnergy = 50
    var currentEnergyText
    
    var startMaxEnergy = 100
    var currentFocus = 50
    var maxFocus = maxEnergy * 3
    
    var budget = 60

    var power
    var budgetRatio = budget/income
    var budgetAccuracy = 0.9

    var chaosFactor = 0.0
    var chaosMultiplierMin = 0.7
    var chaosMultiplierMax = 2.5

    var playerHitCheck = false
    var enemy1HitCheck = false

    var enemy1Life = budget
    var enemy1Alive
    

  

    class HealthBar {

        constructor (scene,startLife, x, y)
        {
            this.bg = new Phaser.GameObjects.Graphics(scene).setDepth(1);
            
            this.lifeBar = new Phaser.GameObjects.Graphics(scene).setDepth(1);
            this.energyBar = new Phaser.GameObjects.Graphics(scene).setDepth(1);
            this.focusBar = new Phaser.GameObjects.Graphics(scene).setDepth(1);

            this.x = x;
            this.y = y;
            
            this.pL =  38 / maxLife
            this.pE =  38 / maxEnergy
            this.pF =  38 / maxFocus 

            this.draw();

            scene.add.existing(this.bg)
            scene.add.existing(this.lifeBar);
            scene.add.existing(this.energyBar);
            scene.add.existing(this.focusBar);
        }

        decreaseLife (amount)
        {
            currentLife -= amount;

            if (currentLife < 0)
            {
                currentLife = 0;
            }

            this.draw();

            return (currentLife === 0);
        }

        decreaseEnergy (amount)
        {
            currentEnergy -= amount;

            if (currentEnergy < 0)
            {
                currentEnergy = 0;
            }
            

            this.draw();

            return (currentEnergy === 0);
        }

        decreaseFocus (amount)
        {
            currentFocus -= amount;

            if (currentFocus < 0)
            {
                currentFocus = 0;
            }

            this.draw();

            return (currentFocus === 0);
        }

        draw ()
        {
            this.bg.clear()
            this.lifeBar.clear();
            this.energyBar.clear();
            this.focusBar.clear();

            //  BG
            this.bg.fillStyle(0x000000);
            this.bg.fillRect(this.x, this.y, 40, 13);

            //  Health

            this.lifeBar.fillStyle(0xffffff);
            this.lifeBar.fillRect(this.x + 1, this.y + 1, 38, 3);
            this.lifeBar.fillStyle(0xcc0000);


            var d = Math.floor(this.pL * currentLife);

            this.lifeBar.fillRect(this.x + 1, this.y + 1, d, 3);

            //  Energy

            this.energyBar.fillStyle(0xffffff);
            this.energyBar.fillRect(this.x + 1, this.y + 5, 38 * (maxEnergy/startMaxEnergy) , 3);
            this.energyBar.fillStyle(0x93c47d);
        

            var d = Math.floor(this.pE * currentEnergy);

            this.energyBar.fillRect(this.x + 1, this.y + 5, d, 3);

            //  Focus

            this.focusBar.fillStyle(0xffffff);
            this.focusBar.fillRect(this.x + 1, this.y + 9, 38, 3);
            this.focusBar.fillStyle(0xf1c232);
            

            var d = Math.floor(this.pF * currentFocus);

            this.focusBar.fillRect(this.x + 1, this.y + 9, d, 3);
        }

    }

    class ProgressBar {

    constructor (scene,distanceTravelled, x, y)
    {
        this.bg = new Phaser.GameObjects.Graphics(scene).setDepth(4);
        
        this.progressBar = new Phaser.GameObjects.Graphics(scene).setDepth(4);

        this.x = x;
        this.y = y;
        
        this.p =  38 / distanceToTravel

        this.draw();

        scene.add.existing(this.bg)
        scene.add.existing(this.progressBar);
        
    }

    increaseDistance (amount)
    {
        distanceTravelled += amount;

        if (distanceTravelled > distanceToTravel)
        {
            distanceTravelled = distanceToTravel;
        }

        this.draw();

        return (distanceTravelled === distanceToTravel);
    }

    

        

        draw ()
        {
            this.bg.clear()
            this.progressBar.clear();
           

            //  BG
            this.bg.fillStyle(0x000000);
            this.bg.fillRect(this.x, this.y, width/2, 25);

            //  Health

            this.progressBar.fillStyle(0xffffff);
            this.progressBar.fillRect(this.x + 1, this.y + 1, width/2-2, 23);
            this.progressBar.fillStyle(0x674EA7);


            var d = Math.floor(this.p * distanceTravelled);

            this.progressBar.fillRect(this.x + 1, this.y + 1, d, 23);

            
        }

    }
       
   

    function grabbed(){

        if (inBattle == false) {

            player.anims.play({key:'pDash',frameRate: 12},true);

            player.body.maxVelocity.x = 250
            player.setVelocityX(250)
            player.setDragX(500)
            enemy1.setDragX(300)

            player.flipX = true
            inBattle = true
            if (currentLife <= 0){
                playerVitals.decreaseEnergy(currentEnergy * 0.05)
            } else {
                playerVitals.decreaseLife(currentLife * 0.05)
            }
            
            income *= 1 - 0.04

            camera.startFollow(player, false, 0.05, 0.05)


        }
                

    }

    function playerComboEnd() {
        
        keyDuration = 0
        chargePower = 0
    }

    function playerHit(){

                    
                      if (playerHitCheck == true){
                        player.anims.play({key:'pHurt'},true);
                        playerVitals.decreaseLife(currentLife * 0.025)
                        maxEnergy *= 1 - 0.04
                      }
                      
                                   
              
               
    }

    function enemy1Hit(){

        if (inBattle) {              
        if (enemy1Hit == false){
            enemy1Hit = true
            var chaos = Phaser.Math.FloatBetween(0.00,1.00)
            if (chargePower > .75 && chaos < 0.075){
           
            camera.flash(150);
            camera.shake(500, 0.01);
            damage *= Phaser.Math.Between(1.5,3)
            enemy1Life -= damage
            enemy1.x -= Phaser.Math.Between(-15,15)
            } else
            if (chargePower > .15 && chaos < 0.1){
            camera.shake(500, 0.005);
            damage *= Phaser.Math.Between(1.1,2.5)
            enemy1Life -= damage
            enemy1.x -= Phaser.Math.Between(-15,15)
            } else {
                damage *= Phaser.Math.Between(0.8,1.15)
                enemy1Life -= damage 
                enemy1.x -= Phaser.Math.Between(-10,10)

       
            }
            
             
            

        } 
    }             
                 
    }

    function enemy1Recover(){

        if (enemy1Hit){
            enemy1Hit = false 
        }

    }

   
  

    

    function runYearlyFunctions()
    {
       if (inBattle == false) {

        //maxEnergy *= 1 - (0.04 / 12)
        income *= 1 - (0.04 / 12)
       // budget *= 1 - (0.04 / 12)
        // enemyYearly.setDragX(0)
        // enemy1.setVelocity(Phaser.Math.Between(100 * chaosMultiplierMin, 100 * chaosMultiplierMax))
        // enemy1Life = budget * chaosFactor
          
        }

        chaosMultiplierMin *= 1.005
        chaosMultiplierMax *= 1.012
        enemy1.setScale(Phaser.Math.FloatBetween(1.75,1.9),Phaser.Math.FloatBetween(1.15,1.35))
  
        
    }

    function runMonthlyFunctions()
    {
       if (inBattle == false) {

        

        enemy1.setScale(Phaser.Math.FloatBetween(1.65,1.8),Phaser.Math.FloatBetween(1.2,1.3))
        enemy1.setDragX(0)
        enemy1.setVelocity(Phaser.Math.Between(100 * chaosMultiplierMin, 100 * chaosMultiplierMax))
        enemy1Life = budget * chaosFactor
          
        }

        chaosMultiplierMin *= 1.003
        chaosMultiplierMax *= 1.005
  
        
    }

    function runWeeklyFunctions()
    {
       if (inBattle == false) {

        var totalEnergy = currentEnergy + (energyRegen / 4)
        currentEnergy = Phaser.Math.MaxAdd(currentEnergy, (energyRegen / 4),maxEnergy) 
        currentFocus = Phaser.Math.MaxAdd(currentFocus,totalEnergy - currentEnergy + (focusRegen /4),maxFocus)

       
        // enemyWeekly.setDragX(0)
        // enemy1.setVelocity(Phaser.Math.Between(100 * chaosMultiplierMin, 100 * chaosMultiplierMax))
        // enemy1Life = budget * chaosFactor
          
        }

        chaosMultiplierMin *= 1.002
        chaosMultiplierMax *= 1.003
  
        
    }

    function runDailyFunctions()
    {
       if (inBattle == false) {

        // var totalEnergy = currentEnergy + energyRegen
        // currentEnergy = Phaser.Math.MaxAdd(currentEnergy, energyRegen,maxEnergy) 
        // currentFocus = Phaser.Math.MaxAdd(currentFocus,totalEnergy - currentEnergy + focusRegen,maxFocus)

        
        // enemyDaily.setDragX(0)
        // enemy1.setVelocity(Phaser.Math.Between(100 * chaosMultiplierMin, 100 * chaosMultiplierMax))
        // enemy1Life = budget * chaosFactor
          
        }

  
        
    }


    function preload ()
    {
        this.load.image('up', 'assets/buttonUp.png');
        this.load.image('down', 'assets/buttonDown.png');
        this.load.image('deadSpace', 'assets/buttonDeadSpace.png');
        this.load.image('left', 'assets/buttonLeft.png');
        this.load.image('right', 'assets/buttonRight.png');
        this.load.image('energy', 'assets/buttonEnergy.png');
        this.load.image('focus', 'assets/buttonFocus.png');
        this.load.image('dawnl1', 'assets/dawn1.png');
        this.load.image('dawnl2', 'assets/dawn2.png');
        this.load.image('dawnl3', 'assets/dawn3.png');
        this.load.image('dawnl4', 'assets/dawn4.png');
        this.load.image('dawnl5', 'assets/dawn5.png');
        this.load.image('dawnl6', 'assets/dawn6.png');
        this.load.image('dawnl7', 'assets/dawn7.png');
        this.load.image('dawnl8', 'assets/dawn8.png');

        this.load.image('woodsl1', 'assets/woods1.png');
        this.load.image('woodsl2', 'assets/woods2.png');
        this.load.image('woodsl3', 'assets/woods3.png');
        this.load.image('woodsl4', 'assets/woods4.png');

        this.load.image('vines', 'assets/vines.png');

        this.load.image('ground', 'assets/woodground.png');


        this.load.atlas('logan', 'assets/loganv2.png','assets/loganspritesv2.json');
        this.load.atlas('doomsayer', 'assets/doomsayer.png','assets/doomsayersprites.json');
        this.load.atlas('heroF', 'assets/heroF.png','assets/heroF.json');
        this.load.atlas('heroM', 'assets/heroM.png','assets/heroM.json');

        this.load.spritesheet('chargeEnergy', 'assets/animations/17_felspell_spritesheet.png', { frameWidth: 100, frameHeight: 100});
  

    }

    function create ()
    {


        startPosition = (width * 1.5)

        this.physics.world.setBounds(0, 0, width * 3,  height);
        
        this.woodsl1 = this.add.tileSprite(0,0, width * 3, height, 'woodsl1').setOrigin(0,0).setScrollFactor(0)
        this.woodsl2 = this.add.tileSprite(0,0, width * 3, height, 'woodsl2').setOrigin(0,0).setScrollFactor(0.25)
        this.woodsl3 = this.add.tileSprite(0,0, width * 3, height, 'woodsl3').setOrigin(0,0).setScrollFactor(0.5)
        this.woodsl4 = this.add.tileSprite(0,0, width * 3, height, 'woodsl4').setOrigin(0,0).setScrollFactor(1).setDepth(2)

        
        this.lights.enable();
        this.lights.setAmbientColor(0x808080);

        spotlight = this.lights.addLight(400, 300, 280).setIntensity(0.5);
        spotlight2 = this.lights.addLight(400, 300, 280).setIntensity(0.25);
       
        platforms = this.physics.add.staticGroup();
        platforms.create(0, height - 50, 'ground').setOrigin(0,0).setScale(width * 3 /400).refreshBody().setVisible(0);

        player = this.physics.add.sprite(startPosition, height - 90 ,'heroF').setScale(2).setPipeline('Light2D');
        player.setDepth(1)
        player.tint = 0xdd7e6b;
        currentLife = startLife
        playerVitals = new HealthBar(this,startLife, player.x, player.y - 50);
        

        player.body.setSize(10, 30).setOffset(25,15).setAllowDrag(true)
        player.body.maxVelocity.x = 250
        player.setBounceY(0.15);
        player.setCollideWorldBounds(true);

        sword = this.add.rectangle(player.x, player.y, 60, 60);
        this.physics.add.existing(sword, false)
        sword.body.setAllowGravity(false).setOffset(0,5)
        sword.body.checkCollision.none = true

        pSFX = this.add.sprite(player.x, player.y)
        pSFX.setAlpha(0.75).setDepth(1).setPipeline('Light2D')
        
        this.physics.add.collider(player,platforms);

        this.vines = this.add.image(player.x,player.y - 120, 'vines').setOrigin(0,0).setDepth(1).setScale(0.35,0.45).setTint(0xed8a8a)


            enemy1 = this.physics.add.sprite(0, height - 85, 'doomsayer').setScale(1.75, 1.2).setPipeline('Light2D');
            
            enemy1.setDepth(0)
            enemy1.flipX = true
            enemy1.body.maxVelocity.x = 300
            enemy1.setCollideWorldBounds(true)
            
            this.physics.add.overlap(enemy1, player, grabbed);
            this.physics.add.overlap(enemy1, player, playerHit)
            this.physics.add.overlap(sword, enemy1, enemy1Hit)
            this.physics.add.collider(platforms,enemy1);
            
            enemy1.anims.play({key:'eRun',frameRate: 10},true);
            enemy1.body.setAllowDrag(true)
            
            enemy1Life = budget * Phaser.Math.Between(0.8,1.7)
            enemy1Alive = true

            
        camera = this.cameras.main.centerOn(player.x, 0) //.startFollow(player, false, 0.05, 0.05)

        camera.setBounds(0, 0, width * 3, height)
        
        camera.fadeIn(6000)

        playerProgress = new ProgressBar(this,distanceTravelled, player.x - 75, player.y - 50);

        // 96 seconds = 1 year
        // 8 seconds = 1 month
        // 2 second per week
        // 0.285 seconds per day

        yearlyTimer = this.time.addEvent({delay: 96000, callback: runYearlyFunctions, args: [], callbackScope: this, loop: true});
        monthlyTimer = this.time.addEvent({delay: 8000, callback: runMonthlyFunctions, args: [], callbackScope: this, loop: true});
        weeklyTimer = this.time.addEvent({delay: 2000, callback: runWeeklyFunctions, args: [], callbackScope: this, loop: true});
        dailyTimer = this.time.addEvent({delay: 285, callback: runDailyFunctions, args: [], callbackScope: this, loop: true});

        this.anims.create({
            key: 'chargeEnergy',
            frames: this.anims.generateFrameNumbers('chargeEnergy', { start:0, end: 91}),
            frameRate: 100,
            repeat: 0,
            //yoyo: true
        });

        this.anims.create({
            key: 'pIdle',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Idle_', start: 1, end: 6, suffix: '.png'}),
            frameRate: 6,
            repeat: -1
        });

       

        this.anims.create({
            key: 'pDeath',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Death_', start: 1, end: 11, suffix: '.png'}),
            frameRate: 12,
            repeat: 0
        });
     

        this.anims.create({
            key: 'pHurt',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_hurt_', start: 1, end: 4, suffix: '.png'}),
            frameRate: 4,
            repeat: 0
        });

        this.anims.create({
            key: 'pSlide',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior-Slide_', start: 1, end: 4, suffix: '.png'}),
            frameRate: 14,
            repeat: 0
        });

        this.anims.create({
            key: 'pJump',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Jump_', start: 1, end: 3, suffix: '.png'}),
            frameRate: 12,
            repeat: 0
        });

        this.anims.create({
            key: 'pUptoFall',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_UptoFall_', start: 1, end: 2, suffix: '.png'}),
            frameRate: 10,
            repeat: 0
        });

        this.anims.create({
            key: 'pRun',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Run_', start: 1, end: 8, suffix: '.png'}),
            frameRate: 14,
            repeat: 0,
            //delay: 1
        });

        this.anims.create({
            key: 'pDash',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Dash_', start: 1, end: 7, suffix: '.png'}),
            frameRate: 14,
            repeat: 0,
            //delay: 1
        });

        this.anims.create({
            key: 'pAttack',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Attack_', start: 1, end: 12, suffix: '.png'}),
            frameRate: 14,
            repeat: 0,
            //delay: 1
        });

        this.anims.create({
            key: 'pQuickAttack',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Attack_', start: 1, end: 8, suffix: '.png'}),
            frameRate: 14,
            repeat: 0,
            //delay: 1
        });

        this.anims.create({
            key: 'pChargeAttack',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Attack_', start: 1, end: 3, suffix: '.png'}),
            frameRate: 6,
            repeat: 0,
            //yoyo: true,
            //delay: 1
        });

        this.anims.create({
            key: 'pHeavyAttack',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Dash-Attack_', start: 1, end: 10, suffix: '.png'}),
            frameRate: 14,
            repeat: 0,
            //delay: 1
        });

        this.anims.create({
            key: 'pChargeEnergy',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Crouch_', start: 1, end: 6, suffix: '.png'}),
            frameRate: 4,
            repeat: 0,
            //yoyo: true,
            //delay: 500
        });





    
        this.anims.create({
            key: 'eIdle',
            frames: this.anims.generateFrameNames('doomsayer',{prefix: 'idle', start: 1, end: 8}),
            frameRate: 10,
            repeat: -1
        });

       
        this.anims.create({
            key: 'eRun',
            frames: this.anims.generateFrameNames('doomsayer',{prefix: 'walk', start: 1, end: 8}),
            frameRate: 10,
            repeat: 0
        });


        this.anims.create({
            key: 'eAttack',
            frames: this.anims.generateFrameNames('doomsayer',{prefix: 'attack', start: 1, end: 10}),
            frameRate: 10,
            repeat: 0,
            
            delay: Math.random() * 1500
            
        });

        this.anims.create({
            key: 'eHurt',
            frames: this.anims.generateFrameNames('doomsayer',{prefix: 'hurt', start: 1, end: 3}),
            frameRate: 10,
            repeat: 0
        });

        this.anims.create({
            key: 'eDeath',
            frames: this.anims.generateFrameNames('doomsayer',{prefix: 'death', start: 1, end: 10}),
            frameRate: 12,
            repeat: 0,
            hideOnComplete: true
            
        });

       


        // Controllers online
        cursors = this.input.keyboard.createCursorKeys();
        keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
        // Touch Screen Support
        
        this.input.addPointer(5);
        up = this.add.image(-100, -100, 'up').setInteractive().setDepth(3).setScale(0.75).setAlpha(0.5);
        down = this.add.image(-100, -100, 'down').setInteractive().setDepth(3).setScale(0.75).setAlpha(0.5);
        left = this.add.image(-100, -100, 'left').setInteractive().setDepth(3).setScale(0.75).setAlpha(0.5);
        right = this.add.image(-100, -100, 'right').setInteractive().setDepth(3).setScale(0.75).setAlpha(0.5);
        deadSpace = this.add.image(-100, -100, 'deadSpace').setDepth(4).setScale(0.75).setAlpha(0.5);
        energy = this.add.image(-100, -100, 'energy').setInteractive().setDepth(3).setScale(1).setAlpha(0.5);
        focusB = this.add.image(-100, -100, 'focus').setInteractive().setDepth(3).setScale(1).setAlpha(0.5);

        this.input.on('pointerdown', function (pointer) {
        IS_TOUCH = true;
        })

        this.input.on('gameobjectdown', function (pointer, gameObject) {
        
        
           

        gameObject.setAlpha(1);
        
        if (gameObject == up){
            cursors.up.isDown = true
        }

        if (gameObject == down){
            cursors.down.isDown = true
        }

        if (gameObject == left){
            cursors.left.isDown = true
        } 

        if (gameObject == right){
            cursors.right.isDown = true
        }

        if (gameObject == energy){
            keyA.isDown = true
            player.anims.play({key:'pChargeAttack',frameRate: 16},true);
            keyA.isUp = false
        }

        if (gameObject == focusB){
            cursors.space.isDown = true
            // player.anims.play({key:'pChargeAttack',frameRate: 16},true);
            // keyA.isUp = false
        }

        });

        this.input.on('gameobjectup', function (pointer, gameObject) {

        gameObject.setAlpha(0.5);

        if (gameObject == up){
            cursors.up.isDown = false
        }

        if (gameObject == down){
            cursors.down.isDown = false
        }

        if (gameObject == left){
            cursors.left.isDown = false
        }

        if (gameObject == right){
            cursors.right.isDown = false
        }

        if (gameObject == energy){
            keyA.isDown = false
            keyA.isUp = true
        }

        if (gameObject == focusB){
            cursors.space.isDown = false
            // keyA.isUp = true
        }

        });

        this.input.on('gameobjectout', function (pointer, gameObject) {

            gameObject.setAlpha(0.5);

            if (gameObject == up){
                cursors.up.isDown = false
            }

            if (gameObject == down){
                cursors.down.isDown = false
            }

            if (gameObject == left){
                cursors.left.isDown = false
            }

            if (gameObject == right){
                cursors.right.isDown = false
            }

            if (gameObject == energy){
                keyA.isDown = false
                keyA.isUp = true
            }

            if (gameObject == focusB){
                cursors.space.isDown = false
                // keyA.isUp = true
            }

            });
    

    }

    function moveVines (vine,speed){
    
        vine.x -= speed;
        if (vine.x < width / 2){
            resetVines(vine)
        }

        
    }

    function resetVines (vine){
        vine.x = width * 3
        var scaleXRandom = Phaser.Math.FloatBetween(0.15,0.45)
        var scaleYRandom = Phaser.Math.FloatBetween(0.3,0.55)
        vine.setScale(scaleXRandom,scaleYRandom)
    }

    function update ()
    {

         // v2 Player runs on spot, and tween 

        // Player uses energy (auto via budget) to set velocity and coast on momentum, and to avoid incoming obstacles (budget/some stat determines auto dodge)

        // Enemies spawn and charge at intervals relating to a [month]

        // Player auto clears incoming obstacles provided they have enough energy (has a cost, identifiable visually), can use focus instead manually.  Challenge is balancing with monster chasing, requiring energy expenditure to avoid.  Obstacles cover the baseline outgoings per month, monster reps unexpected.  Remaining energy can be 'invested' (mechanics tbc) or is swept into savings each cycle -

        // enemy constantly eating a random amount of player energy (or at set intervals)
        // Income - budget = energy regen
        // As time passes, energy regen decreases by 4% (inflation) + x% (diffuclty ramp) per interval, and more enemies of higher chaos multipliers appear)
        // Enemy can sprint, rep unexpected cost, accelratin up to player (higher accelration = larger unexpected cost)  
        // Player can expend further energy to accelerate, and while sprinting cuts enemy accelration
        

        player.setTint()
        
        if (player.flipX){
            sword.x = player.x - 10
            sword.y = player.y - 15
        } else {
            sword.x = player.x + 10
            sword.y = player.y - 15
        }

        sword.body.checkCollision.none = true
        playerHitCheck = false
        playerVitals.x = player.x + 25
        playerVitals.y = player.y - 20
        playerVitals.draw()

        playerProgress.x = camera.scrollX + width * 0.25
        playerProgress.y = camera.scrollY + height * 0.05
        playerProgress.draw()

        if(IS_TOUCH){
        left.x = camera.scrollX + (width * 0.1)// - 245 
        energy.x = camera.scrollX + (width * 0.9) 

        deadSpace.x = left.x + 40.5
        right.x = deadSpace.x + 40.5
        up.x = deadSpace.x
        down.x = deadSpace.x
        focusB.x = energy.x - 75

        left.y = camera.scrollY + (height - 85)
        energy.y = camera.scrollY + (height - 106)

        deadSpace.y = left.y
        right.y = deadSpace.y
        up.y = deadSpace.y - 40.5
        down.y = left.y + 40.5
        focusB.y = energy.y + 53
        }

        

        spotlight.x = player.x
        spotlight.y = player.y

        if (player.flipX){
            pSFX.x = player.x + 10
        } else {
            pSFX.x = player.x - 5
        }
        
        pSFX.y = player.y

        enemy1.y = height - 85

        console.log('Enemy 1 Life: ' + enemy1Life)
        console.log('Player: ' + player.body.speed)
        console.log('Charge Power %: ' + chargePower * 100)
       console.log('Damage: ' + damage)
      
       
       console.log('Enemy Chaos Factor: ' + chaosFactor)

        

        
        playerPosition = player.x
        
        playerSpeed = playerPosition / (width * 1.5)
        
        if (inBattle == false){
            this.woodsl2.tilePositionX += 1 * (playerSpeed)
            this.woodsl3.tilePositionX += 2 * (playerSpeed)
            this.woodsl4.tilePositionX += 4.5 * (playerSpeed)
            this.woodsl4.setAlpha(1) 
            camera.zoomTo(1,750) 
        } else if (inBattle) {
            this.woodsl2.tilePositionX = camera.x * 0.3
            this.woodsl3.tilePositionX = camera.x * 0.6
            this.woodsl4.tilePositionX = camera.x
            this.woodsl4.setAlpha(0.9)
            camera.zoomTo(1.15,750)
        }
        
  

        chaosFactor = Phaser.Math.FloatBetween(chaosMultiplierMin,chaosMultiplierMax)
        enemy1.body.setSize(enemy1.width, enemy1.height)


        if (inBattle == false){

            player.flipX = false

            spotlight.intensity = 0.5

            if (enemy1.x > width * 1.55 && player.x > width * 1.6){
                        enemy1.setVelocityX(-100)
            }

            moveVines(this.vines,3)
            
            if (cursors.space.isDown && currentFocus > 0){

                distanceTravelled += 8

                playerVitals.decreaseFocus(maxEnergy / 450)
                player.anims.play({key:'pDash',frameRate: 12},true);

            
                player.body.maxVelocity.x = 300
                player.setVelocityX(200)
                //this.physics.moveTo(player,width * 1.8,height - 90,300)

        

                
            } 

            else if (Phaser.Input.Keyboard.JustDown(cursors.space)){
                
                
                player.setDragX(5000)

            
            } else if (cursors.down.isDown && currentEnergy > 0){

                playerVitals.decreaseEnergy(maxEnergy / 300)

                distanceTravelled += 1
            
                if(Phaser.Input.Keyboard.JustDown(cursors.down)){
                    //player.chain([ {key:'pUptoFall',frameRate: 12},true, {key:'pSlide',frameRate: 6},true]);
                    player.anims.play({key:'pSlide',frameRate: 6},true);
                }
                


                enemy1.anims.play({key:'eRun',frameRate: 12},true);

                this.physics.moveTo(player,width * 1.4,height - 90,30)
            
            } else if (cursors.left.isDown && currentEnergy > 0 && currentLife < maxLife){

                moveVines(this.vines,-0.5)

                playerVitals.decreaseEnergy(maxEnergy / 900)
                playerVitals.decreaseLife(-maxEnergy / 900)

                player.anims.play({key:'pChargeEnergy'},true);
                        pSFX.setTint(0xcc0000)
                        pSFX.play('chargeEnergy',true)
                        if (spotlight.intensity < 1.5){
                        spotlight.intensity += 0.02
                        }
                camera.shake(50, 0.0005);

                distanceTravelled += 2

                this.physics.moveTo(player,width * 1.4,height - 90,90)
                player.anims.play({key:'pRun',frameRate: 8},true);
                enemy1.anims.play({key:'eRun',frameRate: 8},true);

                
            } else if (cursors.right.isDown && currentEnergy > 0){

                moveVines(this.vines,1.5)
                
                playerVitals.decreaseEnergy(maxEnergy / 600)
                this.physics.moveTo(player,width * 1.7,height - 90,90)
                player.anims.play({key:'pRun',frameRate: 16},true);
                enemy1.anims.play({key:'eRun',frameRate: 14},true);

                distanceTravelled += 6
                    
                 
            } else {

                distanceTravelled += 3

                playerVitals.decreaseEnergy(maxEnergy / 1500)
                this.physics.moveTo(player,width * 1.5,height - 90,150)
                player.anims.play({key:'pRun',frameRate: 12},true);
                enemy1.anims.play({key:'eRun',frameRate: 10},true);

            }

        } else if (inBattle) {
            // In Battle Mode

            if (enemy1Alive == false){
                enemy1.x = 0
                enemy1.y =  0
                player.flipX = false
                
                inBattle = false
                enemy1Life = budget * chaosFactor
                enemy1Alive = true
            }

            camera.startFollow(player, false, 0.05, 0.05)

            if (player.x - enemy1.x > 0){
                enemy1.flipX = true
            } else {
                enemy1.flipX = false
            }
             
            if (enemy1Hit){
                enemy1.anims.play({key:'eHurt',frameRate: 12},true); 
                enemy1.on('animationcomplete', function () {
                    enemy1Recover();
                }, this);
            } else if (enemy1Alive && enemy1Life > 0 && enemy1Hit == false && Math.abs(player.x - enemy1.x) >= 100) {
            
                    this.physics.moveToObject(enemy1,player,200)
                    enemy1.anims.play({key:'eRun',frameRate: 12},true); 
                    
                    
            } else if (enemy1Alive && enemy1Life > 0 && enemy1Hit == false){

                enemy1.anims.play({key:'eIdle',frameRate: 10},true);

                

            
                           
                
            } else if (enemy1Life <=0 && enemy1Alive){
                    
                enemy1.anims.play({key:'eDeath'},true);
                
                if (enemy1.anims.currentFrame.index > 9){
                enemy1Alive = false
                }
                    
            }

            
             

            
            if (enemy1HitCheck){
                if (player.flipX){
                    this.physics.moveTo(enemy1,enemy1.x - 100,enemy1.y,100)
                    
                        
                } else {
                    this.physics.moveTo(enemy1,enemy1.x + 100,enemy1.y,100)
                        
                        
                }
                
            } 

            
            
            

            player.body.setSize(10, 30).setOffset(25,15)

           if(player.body.onFloor()){
            
                player.setDragX(600)
            
            
            } else {
                player.setDragX(100)
            }
           
          
            
             enemy1.setDragX(600)
            
           

            
            
            if (playerHitCheck == false){

                // if (cursors.up.isDown && player.body.touching.down){
                //     player.anims.play({key:'pJump',frameRate: 10},true);
                //     player.setVelocityY(-225)
                //     if (player.body.velocity.x < 0){
                //         player.setVelocityX(player.body.velocity.x - 50)
                //     } else if (player.body.velocity.x > 0) {
                //         player.setVelocityX(player.body.velocity.x + 50)
                //     }
                // } else 
                if ((cursors.left.isDown && keyA.isDown || cursors.right.isDown && keyA.isDown) && currentEnergy > 0){
                   
                    player.anims.play({key:'pHeavyAttack',frameRate: 12},true);

                   
                    playerVitals.decreaseEnergy(maxEnergy / 300)
                    damage = maxEnergy * 0.75

                    // Activate Sword Hitbox

                    if (player.anims.currentFrame.index >= 4 && player.anims.currentFrame.index < 6){
                    sword.body.checkCollision.none = false
                    } 

                } else if (keyA.isDown && currentEnergy > 0 && cursors.up.isUp){
                    
                    if(Phaser.Input.Keyboard.JustDown(keyA)){
                        player.anims.play({key:'pChargeAttack'},true);
                    }
                    
                    if (spotlight.intensity < 1.25){
                        spotlight.intensity += 0.01
                    }
                    
                    
                    if (chargePower <= 1.1){
                        chargePower += 0.025
                    }

                    damage = maxEnergy * 0.5 * chargePower

                    keyDuration = keyA.getDuration()
                    if (chargePower < 0.95){
                        playerVitals.decreaseEnergy(maxEnergy / 300)
                    } else {
                        playerVitals.decreaseEnergy(maxEnergy / 600)
                    }
                    

                   
                } else if (cursors.up.isDown && cursors.space.isDown && currentFocus > 0 && currentEnergy < maxEnergy * 0.99){   
                  
                        player.anims.play({key:'pChargeEnergy'},true);
                        pSFX.setTint(0x93c47d)
                        pSFX.play('chargeEnergy',true)
                        if (spotlight.intensity < 1.5){
                        spotlight.intensity += 0.02
                        }
                        camera.shake(50, 0.0005);
                  
                    
                    playerVitals.decreaseFocus(maxFocus / 600)
                    playerVitals.decreaseEnergy(-maxFocus / 600)
                     
                    
                } else if (cursors.up.isDown && keyA.isDown && currentEnergy > 0 && currentFocus < maxFocus * 0.99){   
                  
                        player.anims.play({key:'pChargeEnergy'},true);
                        pSFX.setTint(0xf1c232)
                        pSFX.play('chargeEnergy',true)
                        if (spotlight.intensity < 1.5){
                        spotlight.intensity += 0.02
                        }
                        camera.shake(50, 0.0005);
                  
                    
                    playerVitals.decreaseEnergy(maxEnergy / 600)
                    playerVitals.decreaseFocus(-maxEnergy / 600)
                     
                    
                } else if (keyA.isUp && keyDuration > 0){

                    if (player.anims.currentFrame.index >= 6 && player.anims.currentFrame.index < 12){
                            sword.body.checkCollision.none = false
                    }

                    spotlight.setIntensity(0.5)

                    

                  if (chargePower > 0.75){
         
                        player.anims.play({key:'pAttack',frameRate: 24, startFrame: 3, repeat: 1},true);
                          
                    } else if (chargePower >= 0.25 && chargePower < 0.75){
                        player.anims.play({key:'pAttack',frameRate: 16, startFrame: 3},true);
                    } else if (chargePower <  0.25){
                        player.anims.play({key:'pQuickAttack',frameRate: 18, startFrame: 3, endFrame: 8},true);
                    }

                    player.on('animationcomplete', function () {    
                    playerComboEnd();
                    }, this);
 

                } else if (cursors.space.isDown && currentFocus > 0 && cursors.up.isUp){

                    player.anims.play({key:'pDash',frameRate: 12},true);

                    playerVitals.decreaseFocus(maxEnergy / 400)

                    if (player.flipX){
                        
                        player.body.maxVelocity.x = 500
                        this.physics.moveTo(player,player.x - 100,height - 90,500)

                    } else if (player.flipX == false) {

                        
                        player.body.maxVelocity.x = 500
                        this.physics.moveTo(player,player.x + 100,height - 90,500)
                        
                    }

                } 
                
                else if (Phaser.Input.Keyboard.JustDown(cursors.space)){

                    player.setDragX(5000)

                } 
                
                else if (cursors.down.isDown && player.body.touching.down){ 
                    
                    if(Phaser.Input.Keyboard.JustDown(cursors.down)){
                    //player.chain([ {key:'pUptoFall',frameRate: 12},true, {key:'pSlide',frameRate: 6},true]);
                    player.anims.play({key:'pSlide',frameRate: 12},true);
                    }
                    
                    player.setDragX(300)
                          
                } 
                
                else if (cursors.left.isDown && player.body.touching.down){

                    player.setVelocityX(player.body.velocity.x - (20 * devicePixelRatio))
                    player.flipX = true 
                    player.anims.play({key:'pRun',frameRate: 10},true);
                    
                    
                } 
                
                else if (cursors.right.isDown && player.body.touching.down){

                    player.setVelocityX(player.body.velocity.x + (20 * devicePixelRatio))
                    player.flipX = false
                    player.anims.play({key:'pRun',frameRate: 10},true);

                }  
                
                else if (player.body.touching.down){

                    player.anims.play({key:'pIdle',frameRate: 8},true);
                    player.body.maxVelocity.x = 250
                    enemy1HitCheck = false
                    spotlight.setIntensity(0.5)

 
                } 
                
                else {
                    player.anims.play({key:'pUptoFall',frameRate: 8});
                    player.body.maxVelocity.x = 250
                    enemy1HitCheck = false
                    spotlight.setIntensity(0.5)
                }

            }

        }

    }
            

        
       
    


</script>

</body>
</html>
