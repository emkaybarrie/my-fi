<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>myFi - The Badlands</title>
    <!-- <preference name="Orientation" value="landscape" /> -->
    <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
            
        }
    </style>
</head>
<body>

<script type="text/javascript">

    var ratio = Math.max((window.innerWidth * window.devicePixelRatio)/ (window.innerHeight * window.devicePixelRatio), (window.innerHeight * window.devicePixelRatio) / (window.innerWidth * window.devicePixelRatio)) 
    var DEFAULT_HEIGHT = 272 //* window.devicePixelRatio // any height you want
    var DEFAULT_WIDTH = ratio * DEFAULT_HEIGHT// * 2


    var config = {
        type: Phaser.AUTO,

        scale: {

            parent: 'mygame',
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH,
            width:  DEFAULT_WIDTH, //592, //window.innerWidth * window.devicePixelRatio
            height: DEFAULT_HEIGHT //272, //window.innerHeight * window.devicePixelRatio
        },
        input: {
            keyboard: true,
            gamepad: true
        },
        physics:{
            default:'arcade',
            arcade:{
                gravity:{x: 0, y:350},
                debug: 0,
                overlapBias: 20
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };


    var game = new Phaser.Game(config);
    var gameOver = false
    var highScore = parseInt(localStorage.getItem('highScore')) || 0;

    var spendingBuffTier = 3
    var savingBuffTier = 6
    var investingBuffTier = 7

    var IS_TOUCH = false


    var width = game.config.width
    var height = game.config.height
    var spotlight
    
    
    var startPosition 
    var playerPosition 
    
    var playerSpeed 
    var distanceToTravel = 20000
    var distanceTravelled = 0
    
     
    var inBattle = false                                       
    var deathBlows = false
    var parry = false

    var income = 100
    var lifeRegenAllocation = 0.3 // Equates to budget % allocated to needs
    var energyRegenAllocation = 0.5
    var focusRegenAllocation = 0.2
    
    var lifeRegen = lifeRegenAllocation * income
    var energyRegen = energyRegenAllocation * income
    var focusRegen = focusRegenAllocation * income

    var chargePower = 0
    var keyDuration = 0
    var keyFocusDuration = 0
    var damage = 0

    var maxLife = income * 3
    var startLife = maxLife
    var currentLife 

    var maxEnergy = 100
    var currentEnergy = 50
    var currentEnergyText
    
    var startMaxEnergy = 100
    var currentFocus = 240
    var maxFocus = maxEnergy * 3
    
    var budget = 60

    var power
    var budgetRatio = budget/income
    var budgetAccuracy = 0.9

    var chaosFactor = 0.0
    var chaosMultiplierMin = 0.7
    var chaosMultiplierMax = 2.5

    var playerIsHit = false
    var enemy1IsHit = false
   

    var enemy1Life = budget
    var enemy1Alive
    var e1MaxLife = budget
    var enemy1Aggro = true
    

  

    class HealthBar {

        constructor (scene,startLife, x, y)
        {
            this.bg = new Phaser.GameObjects.Graphics(scene).setDepth(4);
            
            this.lifeBar = new Phaser.GameObjects.Graphics(scene).setDepth(4);
            this.energyBar = new Phaser.GameObjects.Graphics(scene).setDepth(4);
            this.focusBar = new Phaser.GameObjects.Graphics(scene).setDepth(4);

            this.scaleX = 3
            this.scaleY = 3

            this.x = x;
            this.y = y;
            
            this.pL =  (38 * this.scaleX) / maxLife
            this.pE =  (38 * this.scaleX)  / maxEnergy
            this.pF =  (38 * this.scaleX)  / maxFocus 

            this.draw();

            scene.add.existing(this.bg)
            scene.add.existing(this.lifeBar);
            scene.add.existing(this.energyBar);
            scene.add.existing(this.focusBar);
        }

        decreaseLife (amount)
        {
            currentLife -= amount;

            if (currentLife < 0)
            {
                currentLife = 0;
            }

            this.draw();

            return (currentLife === 0);
        }

        decreaseEnergy (amount)
        {
            currentEnergy -= amount;

            if (currentEnergy < 0)
            {
                currentEnergy = 0;
            }
            

            this.draw();

            return (currentEnergy === 0);
        }

        decreaseFocus (amount)
        {
            currentFocus -= amount;

            if (currentFocus < 0)
            {
                currentFocus = 0;
            }

            this.draw();

            return (currentFocus === 0);
        }

        draw ()
        {
            this.bg.clear()
            this.lifeBar.clear();
            this.energyBar.clear();
            this.focusBar.clear();

            //  BG
            this.bg.fillStyle(0x000000);
            this.bg.fillRect(this.x, this.y, (40 * this.scaleX), 13 * this.scaleY);

            //  Health

            this.lifeBar.fillStyle(0xffffff);
            this.lifeBar.fillRect(this.x + (1 * this.scaleX), this.y + (1 * this.scaleY), 38 * this.scaleX, 3 * this.scaleY);
            this.lifeBar.fillStyle(0xcc0000);


            var d = Math.floor(this.pL * currentLife);

            this.lifeBar.fillRect(this.x + (1 * this.scaleX), this.y + (1 * this.scaleY), d , 3 * this.scaleY);

            //  Energy

            this.energyBar.fillStyle(0xffffff);
            this.energyBar.fillRect(this.x + (1 * this.scaleX), this.y + (5 * this.scaleY) , 38 * (maxEnergy/startMaxEnergy) * this.scaleX , 3 * this.scaleY);
            this.energyBar.fillStyle(0x93c47d);
        

            var d = Math.floor(this.pE * currentEnergy);

            this.energyBar.fillRect(this.x + (1 * this.scaleX), this.y + (5 * this.scaleY), d , 3 * this.scaleY);

            //  Focus

            this.focusBar.fillStyle(0xffffff);
            this.focusBar.fillRect(this.x + (1 * this.scaleX), this.y + (9 * this.scaleY), 38 * this.scaleX, 3 * this.scaleY);
            this.focusBar.fillStyle(0xf1c232);
            

            var d = Math.floor(this.pF * currentFocus);

            this.focusBar.fillRect(this.x + (1 * this.scaleX), this.y + (9 * this.scaleY), d  , 3 * this.scaleY);
        }

    }

    class EnemyHealthBar {

    constructor (scene, x, y)
    {
        this.bg = new Phaser.GameObjects.Graphics(scene).setDepth(1);
        
        this.enemyLifeBar = new Phaser.GameObjects.Graphics(scene).setDepth(1);

        this.x = x;
        this.y = y;
        
        this.p =  38 / e1MaxLife

        this.draw();

        scene.add.existing(this.bg)
        scene.add.existing(this.enemyLifeBar);
    }

    decreaseEnemyLife (amount)
    {
        enemy1Life -= amount;

        if (enemy1Life < 0)
        {
            enemy1Life = 0;
        }

        this.draw();

        return (enemy1Life === 0);
    }

    draw ()
    {
        this.bg.clear()
        this.enemyLifeBar.clear();

        //  BG
        this.bg.fillStyle(0x000000);
        this.bg.fillRect(this.x, this.y, 40, 5);

        //  Health

        this.enemyLifeBar.fillStyle(0xffffff);
        this.enemyLifeBar.fillRect(this.x + 1, this.y + 1, 38, 3);
        this.enemyLifeBar.fillStyle(0xcc0000);


        var d = Math.floor(this.p * enemy1Life);
        //this.p =  38 / e1MaxLife

        this.enemyLifeBar.fillRect(this.x + 1, this.y + 1, d, 3);

    }

    }

    class ProgressBar {

    constructor (scene,distanceTravelled, x, y)
    {
        this.bg = new Phaser.GameObjects.Graphics(scene).setDepth(4);
        
        this.progressBar = new Phaser.GameObjects.Graphics(scene).setDepth(4);

        this.x = x;
        this.y = y;
        
        this.p =  (width/3-2) / distanceToTravel

        this.draw();

        scene.add.existing(this.bg)
        scene.add.existing(this.progressBar);
        
    }

    increaseDistance (amount)
    {
        distanceTravelled += amount;

        if (distanceTravelled > distanceToTravel)
        {
            distanceTravelled = distanceToTravel;
        }

        this.draw();

        return (distanceTravelled === distanceToTravel);
    }

    

        

        draw ()
        {
            this.bg.clear()
            this.progressBar.clear();
           

            //  BG
            this.bg.fillStyle(0x000000);
            this.bg.fillRect(this.x, this.y, width/3, 20);

            //  Progress

            this.progressBar.fillStyle(0xffffff);
            this.progressBar.fillRect(this.x + 1, this.y + 1, width/3-2, 18);
            this.progressBar.fillStyle(0x674EA7);


            var d = Math.floor(this.p * distanceTravelled);

            this.progressBar.fillRect(this.x + 1, this.y + 1, d, 18);

            
        }

    }
       
   

    function grabbed(){

        if (inBattle == false) {

            player.anims.play({key:'pDash',frameRate: 12},true);

            player.body.maxVelocity.x = 250
            player.setVelocityX(250)
            player.setDragX(500)
            enemy1.setDragX(300)

            player.flipX = true
            playerIsHit == false
            inBattle = true
            if (currentLife <= 0){
                playerVitals.decreaseEnergy(currentEnergy * 0.05)
            } else {
                playerVitals.decreaseLife(currentLife * 0.05)
            }
            
            income *= 1 - 0.04

            camera.startFollow(player, false, 0.05, 0.05)


        }
                

    }

    function playerComboEnd() {
        
        keyDuration = 0
        keyFocusDuration = 0
        chargePower = 0
    }

    function playerHit(){

                    
                        playerIsHit = true
                        playerVitals.decreaseLife(currentLife * 0.05 / 300)
                        playerVitals.decreaseEnergy(currentEnergy * 0.05 / 300)
                        maxEnergy *= 1 - (0.04 / 300)
                        player.x -= 1
                           
               
    }

    function playerVineHit(){

    if (inBattle == false){
        playerIsHit = true
        playerVitals.decreaseLife((income * 0.3) / 100)
        
        maxEnergy *= 1 - (0.04 / 100)
        player.x -= 1
        enemy1.body.velocity.x += 2
    }            
    

    }

    function playerEnemyHit(){

    if (inBattle){
        //if (playerIsHit == false){
            playerIsHit = true
            playerVitals.decreaseLife(e1MaxLife / 100)
            maxEnergy *= 1 - (0.04 / 100)
            
        //} 
        
    }            


    }

    function playerRecover(){

    if (playerIsHit){
        playerIsHit = false 
    }

    }

    function enemy1Hit(){

        if (inBattle) {              
        
            enemy1IsHit = true
            var chaos = Phaser.Math.FloatBetween(0.00,1.00)
            if (chargePower > .75 && chaos < 0.075){
           
            camera.flash(150);
            camera.shake(500, 0.01);
            damage *= Phaser.Math.Between(1.5,3)
            enemy1Vitals.decreaseEnemyLife(damage )
            //enemy1.x -= Phaser.Math.Between(-15,15)
            } else
            if (chargePower > .15 && chaos < 0.1){
            camera.shake(500, 0.005);
            damage *= Phaser.Math.Between(1.1,2.5)
            enemy1Vitals.decreaseEnemyLife(damage)
            //enemy1.x -= Phaser.Math.Between(-15,15)
            } else {
                damage *= Phaser.Math.Between(0.8,1.15)
                enemy1Vitals.decreaseEnemyLife(damage)
                //enemy1.x -= Phaser.Math.Between(-10,10)

       
            }
             
    }             
                 
    }

    function enemy1Recover(){

        if (enemy1IsHit){
            enemy1IsHit  = false 
        }

    }

    

   
  

    

    function runYearlyFunctions()
    {
       if (inBattle == false) {

        //maxEnergy *= 1 - (0.04 / 12)
        income *= 1 - (0.04 / 12)
       // budget *= 1 - (0.04 / 12)
        // enemyYearly.setDragX(0)
        // enemy1.setVelocity(Phaser.Math.Between(100 * chaosMultiplierMin, 100 * chaosMultiplierMax))
        // enemy1Life = budget * chaosFactor
          
        }

        chaosMultiplierMin *= 1.005
        chaosMultiplierMax *= 1.012
        enemy1.setScale(Phaser.Math.FloatBetween(1.75,1.9),Phaser.Math.FloatBetween(1.15,1.35))
  
        
    }

    function runMonthlyFunctions()
    {
       if (inBattle == false) {

        

        enemy1.setScale(Phaser.Math.FloatBetween(1.65,1.8),Phaser.Math.FloatBetween(1.2,1.3))
        enemy1.setDragX(0)
        enemy1.setVelocity(Phaser.Math.Between(100 * chaosMultiplierMin, 100 * chaosMultiplierMax))
        // e1MaxLife = budget * chaosFactor
        // enemy1Life = e1MaxLife
        
        
          
        }

        chaosMultiplierMin *= 1.003
        chaosMultiplierMax *= 1.005
  
        
    }

    function runWeeklyFunctions()
    {
       if (inBattle == false) {

        var totalEnergy = currentEnergy + (energyRegen / 4)
        currentEnergy = Phaser.Math.MaxAdd(currentEnergy, (energyRegen / 4),maxEnergy) 
        currentFocus = Phaser.Math.MaxAdd(currentFocus,totalEnergy - currentEnergy + (focusRegen /4),maxFocus)

       
        // enemyWeekly.setDragX(0)
        // enemy1.setVelocity(Phaser.Math.Between(100 * chaosMultiplierMin, 100 * chaosMultiplierMax))
        // enemy1Life = budget * chaosFactor
          
        }

        chaosMultiplierMin *= 1.002
        chaosMultiplierMax *= 1.003

      
       
        
  
        
    }

    function runDailyFunctions()
    {
       if (inBattle == false) {

        // var totalEnergy = currentEnergy + energyRegen
        // currentEnergy = Phaser.Math.MaxAdd(currentEnergy, energyRegen,maxEnergy) 
        // currentFocus = Phaser.Math.MaxAdd(currentFocus,totalEnergy - currentEnergy + focusRegen,maxFocus)

        
        // enemyDaily.setDragX(0)
        // enemy1.setVelocity(Phaser.Math.Between(100 * chaosMultiplierMin, 100 * chaosMultiplierMax))
        // enemy1Life = budget * chaosFactor
          
        }

  
        
    }

    function updateHighScore(){
        if (highScore < distanceTravelled){
            highScore = distanceTravelled
        }

        
        localStorage.setItem('highScore',highScore);
    }


    function preload ()
    {
        this.load.image('playerIcon', 'assets/playerIcon.png');

        this.load.image('spendingBuffIcon', 'assets/ach_00059.png');
        this.load.image('savingBuffIcon', 'assets/ach_00057.png');
        this.load.image('investingBuffIcon', 'assets/ach_00046.png');

        this.load.image('t1BuffIcon', 'assets/ach_00117.png');
        this.load.image('t2BuffIcon', 'assets/ach_00118.png');
        this.load.image('t3BuffIcon', 'assets/ach_00119.png');
        this.load.image('t4BuffIcon', 'assets/ach_00120.png');
        this.load.image('t5BuffIcon', 'assets/ach_00121.png');
        this.load.image('t6BuffIcon', 'assets/ach_00122.png');
        this.load.image('t7BuffIcon', 'assets/ach_00091.png');

        this.load.image('up', 'assets/buttonUp.png');
        this.load.image('down', 'assets/buttonDown.png');
        this.load.image('deadSpace', 'assets/buttonDeadSpace.png');
        this.load.image('left', 'assets/buttonLeft.png');
        this.load.image('right', 'assets/buttonRight.png');
        this.load.image('energy', 'assets/buttonEnergy.png');
        this.load.image('focus', 'assets/buttonFocus.png');
        this.load.image('dawnl1', 'assets/dawn1.png');
        this.load.image('dawnl2', 'assets/dawn2.png');
        this.load.image('dawnl3', 'assets/dawn3.png');
        this.load.image('dawnl4', 'assets/dawn4.png');
        this.load.image('dawnl5', 'assets/dawn5.png');
        this.load.image('dawnl6', 'assets/dawn6.png');
        this.load.image('dawnl7', 'assets/dawn7.png');
        this.load.image('dawnl8', 'assets/dawn8.png');

        this.load.image('woodsl1', 'assets/woods1.png');
        this.load.image('woodsl2', 'assets/woods2.png');
        this.load.image('woodsl3', 'assets/woods3.png');
        this.load.image('woodsl4', 'assets/woods4.png');

        this.load.image('vines', 'assets/vines.png');

        this.load.image('ground', 'assets/woodground.png');


        this.load.atlas('logan', 'assets/loganv2.png','assets/loganspritesv2.json');
        this.load.atlas('doomsayer', 'assets/doomsayer.png','assets/doomsayersprites.json');
        this.load.atlas('heroF', 'assets/heroF.png','assets/heroF.json');
        this.load.atlas('heroM', 'assets/heroM.png','assets/heroM.json');

        this.load.spritesheet('chargeEnergy', 'assets/animations/17_felspell_spritesheet.png', { frameWidth: 100, frameHeight: 100});
        this.load.spritesheet('chargeDash', 'assets/animations/chargeDash.png', { frameWidth: 128.5, frameHeight: 128.6});
  

    }

    function create ()
    {

        // Text Instructions - Temp

        text1 = this.add.text(width * 1.35, height * 0.015, 'Make it to the end whilst avoiding enemies and obstables.').setFontFamily('Arial').setFontSize(10).setColor('#674EA7').setDepth(4);
        text2 = this.add.text(text1.x, text1.y + 15, 'Run Mode: Press FORWARD to speed up. Press BACK to slow down & charge focus. Press DOWN to slide/dodge.').setFontFamily('Arial').setFontSize(7).setColor('#ffffff').setDepth(4);
        text3 = this.add.text(text1.x, text2.y + 12.5, 'Run Mode: Press/Hold FOCUS button (yellow) to dash/dodge').setFontFamily('Arial').setFontSize(7).setColor('#ffffff').setDepth(4);
        text4 = this.add.text(text1.x, text3.y + 12.5, 'Battle Mode: Press/Hold ENERGY button (green) to attack. Hold LEFT/RIGHT + ENERGY for Heavy Attack.').setFontFamily('Arial').setFontSize(7).setColor('#ffffff').setDepth(4);
        text5 = this.add.text(text1.x, text4.y + 12.5, 'Battle Mode: Hold UP + FOCUS to charge Energy. Press/Hold FOCUS button (yellow) to dash/dodge').setFontFamily('Arial').setFontSize(7).setColor('#ffffff').setDepth(4);
        
        

        startPosition = (width * 1.5)

        this.physics.world.setBounds(0, 0, width * 3,  height);
        
        this.woodsl1 = this.add.tileSprite(0,0, width * 3, height, 'woodsl1').setOrigin(0,0).setScrollFactor(0)
        this.woodsl2 = this.add.tileSprite(0,0, width * 3, height, 'woodsl2').setOrigin(0,0).setScrollFactor(0.25)
        this.woodsl3 = this.add.tileSprite(0,0, width * 3, height, 'woodsl3').setOrigin(0,0).setScrollFactor(0.5)
        this.woodsl4 = this.add.tileSprite(0,0, width * 3, height, 'woodsl4').setOrigin(0,0).setScrollFactor(1).setDepth(2)

        
        this.lights.enable();
        this.lights.setAmbientColor(0x808080);

        spotlight = this.lights.addLight(400, 300, 280).setIntensity(0.5);
       
        platforms = this.physics.add.staticGroup();
        platforms.create(0, height - 50, 'ground').setOrigin(0,0).setScale(width * 3 /400).refreshBody().setVisible(0);

        player = this.physics.add.sprite(startPosition, height - 90 ,'heroF').setScale(2).setPipeline('Light2D');
        player.setDepth(1)
        player.tint = 0xdd7e6b;
        currentLife = startLife
        
        playerVitals = new HealthBar(this,startLife, player.x, player.y - 50);
        

        player.body.setSize(10, 30).setOffset(25,15).setAllowDrag(true)
        player.body.maxVelocity.x = 250
        player.setBounceY(0.15);
        player.setCollideWorldBounds(true);

        sword = this.add.rectangle(player.x, player.y, 60, 60);
        this.physics.add.existing(sword, false)
        sword.body.setAllowGravity(false).setOffset(0,5)
        sword.body.checkCollision.none = true

        pSFX = this.add.sprite(player.x, player.y)
        pSFX.setAlpha(0.75).setDepth(1).setPipeline('Light2D')
        
        this.physics.add.collider(player,platforms);

        this.vines = this.add.image(player.x,player.y - 120, 'vines').setOrigin(0,0).setDepth(1).setScale(0.35,0.5).setTint(0x38761d) //(0xed8a8a)

        this.physics.add.existing(this.vines,false)
        this.vines.body.setAllowGravity(false)
        this.physics.add.overlap(player,this.vines, playerVineHit);
        this.vines.body.setSize(474,175).setOffset(0,-7.5)


            enemy1 = this.physics.add.sprite(0, height - 85, 'doomsayer').setScale(1.75, 1.2).setPipeline('Light2D');
            
            enemy1.setDepth(0)
            enemy1.flipX = true
            enemy1.body.maxVelocity.x = 300
            enemy1.setCollideWorldBounds(true)
            
            this.physics.add.overlap(enemy1, player, grabbed);
            
            this.physics.add.overlap(sword, enemy1, enemy1Hit)
            this.physics.add.collider(platforms,enemy1);
            
            
            enemy1.body.setAllowDrag(true)
            
            enemy1Life = budget * Phaser.Math.Between(0.8,1.7)
            e1MaxLife = enemy1Life
            enemy1Alive = true

            enemy1Vitals = new EnemyHealthBar(this,enemy1.x, enemy1.y - 50);

            eSword = this.add.rectangle(enemy1.x, enemy1.y, 65, 60);
            this.physics.add.existing(eSword, false)
            eSword.body.setAllowGravity(false).setOffset(0,5)
            eSword.body.checkCollision.none = true
            this.physics.add.overlap(eSword, player, playerEnemyHit);

            
        camera = this.cameras.main.centerOn(player.x, 0) //.startFollow(player, false, 0.05, 0.05)

        camera.setBounds(0, 0, width * 3, height)
        
        camera.fadeIn(6000)

        playerIcon = this.add.image(camera.scrollX + 25,camera.scrollY + 25,'playerIcon').setDepth(4).setScale(2.5)

        spendingBuffIcon = this.add.image(camera.scrollX + 225,camera.scrollY + 25,'spendingBuffIcon').setDepth(4).setScale(0.5)
        savingBuffIcon = this.add.image(camera.scrollX + 350,camera.scrollY + 25,'savingBuffIcon').setDepth(4).setScale(0.5)
        investingBuffIcon = this.add.image(camera.scrollX + 475,camera.scrollY + 25,'investingBuffIcon').setDepth(4).setScale(0.5)

        spendingBuffTierIcon = this.add.image(camera.scrollX + 275,camera.scrollY + 25,'t'+spendingBuffTier+'BuffIcon').setDepth(4).setScale(0.5)
        savingBuffTierIcon = this.add.image(camera.scrollX + 400,camera.scrollY + 25,'t'+savingBuffTier+'BuffIcon').setDepth(4).setScale(0.5)
        investingBuffTierIcon = this.add.image(camera.scrollX + 525,camera.scrollY + 25,'t'+investingBuffTier+'BuffIcon').setDepth(4).setScale(0.2)

        spendingBuffIcon.visible = false
            savingBuffIcon.visible = false
            investingBuffIcon.visible = false
            spendingBuffTierIcon.visible = false
            savingBuffTierIcon.visible = false
            investingBuffTierIcon.visible = false


        playerProgress = new ProgressBar(this,distanceTravelled, camera.scrollX + width * 0.33, camera.scrollY + (height - 85));

        highScoreText = this.add.text(camera.scrollX + (width - 340), camera.scrollY + (height - 57), 'High Score: ' + Math.floor(highScore)).setFontFamily('Arial').setFontSize(12).setColor('#674EA7').setDepth(4);

        // 96 seconds = 1 year
        // 8 seconds = 1 month
        // 2 second per week
        // 0.285 seconds per day

        yearlyTimer = this.time.addEvent({delay: 96000, callback: runYearlyFunctions, args: [], callbackScope: this, loop: true});
        monthlyTimer = this.time.addEvent({delay: 8000, callback: runMonthlyFunctions, args: [], callbackScope: this, loop: true});
        weeklyTimer = this.time.addEvent({delay: 2000, callback: runWeeklyFunctions, args: [], callbackScope: this, loop: true});
        dailyTimer = this.time.addEvent({delay: 285, callback: runDailyFunctions, args: [], callbackScope: this, loop: true});

        this.anims.create({
            key: 'chargeEnergy',
            frames: this.anims.generateFrameNumbers('chargeEnergy', { start:0, end: 91}),
            frameRate: 100,
            repeat: 0,
            //yoyo: true
        });

        this.anims.create({
            key: 'chargeDash',
            frames: this.anims.generateFrameNumbers('chargeDash', { start:0, end: 5}),
            frameRate: 6,
            repeat: 0,
            //yoyo: true
        });

        this.anims.create({
            key: 'pIdle',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Idle_', start: 1, end: 6, suffix: '.png'}),
            frameRate: 6,
            repeat: -1
        });

       

        this.anims.create({
            key: 'pDeath',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Death_', start: 1, end: 11, suffix: '.png'}),
            frameRate: 12,
            repeat: 0
        });
     

        this.anims.create({
            key: 'pHurt',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_hurt_', start: 1, end: 4, suffix: '.png'}),
            frameRate: 4,
            repeat: 0
        });

        this.anims.create({
            key: 'pSlide',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior-Slide_', start: 1, end: 4, suffix: '.png'}),
            frameRate: 14,
            repeat: 0
        });

        this.anims.create({
            key: 'pJump',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Jump_', start: 1, end: 3, suffix: '.png'}),
            frameRate: 12,
            repeat: 0
        });

        this.anims.create({
            key: 'pUptoFall',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_UptoFall_', start: 1, end: 2, suffix: '.png'}),
            frameRate: 10,
            repeat: 0
        });

        this.anims.create({
            key: 'pRun',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Run_', start: 1, end: 8, suffix: '.png'}),
            frameRate: 14,
            repeat: 0,
            //delay: 1
        });

        this.anims.create({
            key: 'pChargeDash',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Dash_', start: 6, end: 6, suffix: '.png'}),
            frameRate: 14,
            repeat: 0,
            //delay: 1
        });

        this.anims.create({
            key: 'pDash',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Dash_', start: 1, end: 7, suffix: '.png'}),
            frameRate: 14,
            repeat: 0,
            //delay: 1
        });

        this.anims.create({
            key: 'pAttack',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Attack_', start: 1, end: 12, suffix: '.png'}),
            frameRate: 14,
            repeat: 0,
            //delay: 1
        });

        this.anims.create({
            key: 'pQuickAttack',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Attack_', start: 1, end: 8, suffix: '.png'}),
            frameRate: 14,
            repeat: 0,
            //delay: 1
        });

        this.anims.create({
            key: 'pChargeAttack',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Attack_', start: 1, end: 3, suffix: '.png'}),
            frameRate: 6,
            repeat: 0,
            //yoyo: true,
            //delay: 1
        });

        this.anims.create({
            key: 'pHeavyAttack',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Dash-Attack_', start: 1, end: 10, suffix: '.png'}),
            frameRate: 14,
            repeat: 0,
            //delay: 1
        });

        this.anims.create({
            key: 'pChargeEnergy',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Crouch_', start: 1, end: 6, suffix: '.png'}),
            frameRate: 4,
            repeat: 0,
            //yoyo: true,
            //delay: 500
        });





    
        this.anims.create({
            key: 'eIdle',
            frames: this.anims.generateFrameNames('doomsayer',{prefix: 'idle', start: 1, end: 8}),
            frameRate: 10,
            repeat: -1
        });

       
        this.anims.create({
            key: 'eRun',
            frames: this.anims.generateFrameNames('doomsayer',{prefix: 'walk', start: 1, end: 8}),
            frameRate: 10,
            repeat: 0
        });


        this.anims.create({
            key: 'eAttack',
            frames: this.anims.generateFrameNames('doomsayer',{prefix: 'attack', start: 1, end: 10}),
            frameRate: 10,
            repeat: -1,
            //delay: Math.random() * 3500,
            repeatDelay: Math.random() * 3000
            
        });

        this.anims.create({
            key: 'eHurt',
            frames: this.anims.generateFrameNames('doomsayer',{prefix: 'hurt', start: 1, end: 3}),
            frameRate: 10,
            repeat: 0
        });

        this.anims.create({
            key: 'eDeath',
            frames: this.anims.generateFrameNames('doomsayer',{prefix: 'death', start: 1, end: 10}),
            frameRate: 12,
            repeat: 0,
            hideOnComplete: true
            
        });

       


        // Controllers online
        cursors = this.input.keyboard.createCursorKeys();
        keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
        // Touch Screen Support
        
        this.input.addPointer(5);
        up = this.add.image(-100, -100, 'up').setInteractive().setDepth(3).setScale(0.75).setAlpha(0.5);
        down = this.add.image(-100, -100, 'down').setInteractive().setDepth(3).setScale(0.75).setAlpha(0.5);
        left = this.add.image(-100, -100, 'left').setInteractive().setDepth(3).setScale(0.75).setAlpha(0.5);
        right = this.add.image(-100, -100, 'right').setInteractive().setDepth(3).setScale(0.75).setAlpha(0.5);
        deadSpace = this.add.image(-100, -100, 'deadSpace').setDepth(4).setScale(0.75).setAlpha(0.5);
        energy = this.add.image(-100, -100, 'energy').setInteractive().setDepth(3).setScale(1).setAlpha(0.5);
        focusB = this.add.image(-100, -100, 'focus').setInteractive().setDepth(3).setScale(1).setAlpha(0.5);

        this.input.on('pointerdown', function (pointer) {
        IS_TOUCH = true;
        })

        this.input.on('gameobjectdown', function (pointer, gameObject) {
        
        
           

        gameObject.setAlpha(1);
        
        if (gameObject == up){
            cursors.up.isDown = true
        }

        if (gameObject == down){
            cursors.down.isDown = true
            
            
        }

        if (gameObject == left){
            cursors.left.isDown = true
        } 

        if (gameObject == right){
            cursors.right.isDown = true
        }

        if (gameObject == energy){
            keyA.isDown = true
            player.anims.play({key:'pChargeAttack',frameRate: 16},true);
            keyA.isUp = false
        }

        if (gameObject == focusB){
            cursors.space.isDown = true
            // player.anims.play({key:'pChargeAttack',frameRate: 16},true);
            // keyA.isUp = false
        }

        });

        this.input.on('gameobjectup', function (pointer, gameObject) {

        gameObject.setAlpha(0.5);

        if (gameObject == up){
            cursors.up.isDown = false
        }

        if (gameObject == down){
            cursors.down.isDown = false
            
        }

        if (gameObject == left){
            cursors.left.isDown = false
        }

        if (gameObject == right){
            cursors.right.isDown = false
        }

        if (gameObject == energy){
            keyA.isDown = false
            keyA.isUp = true
        }

        if (gameObject == focusB){
            cursors.space.isDown = false
            // keyA.isUp = true
        }

        });

        this.input.on('gameobjectout', function (pointer, gameObject) {

            gameObject.setAlpha(0.5);

            if (gameObject == up){
                cursors.up.isDown = false
            }

            if (gameObject == down){
                cursors.down.isDown = false
            }

            if (gameObject == left){
                cursors.left.isDown = false
            }

            if (gameObject == right){
                cursors.right.isDown = false
            }

            if (gameObject == energy){
                keyA.isDown = false
                keyA.isUp = true
            }

            if (gameObject == focusB){
                cursors.space.isDown = false
                // keyA.isUp = true
            }

            });
    

    }

    function moveVines (vine,speed){
    
        vine.x -= speed;
        if (vine.x < width / 2){
            resetVines(vine)
        }

        
    }

    function resetVines (vine){
        vine.x = width * 3
        var scaleXRandom = Phaser.Math.FloatBetween(0.15,0.65)
        var scaleYRandom = Phaser.Math.FloatBetween(0.55,0.8)
        vine.setScale(scaleXRandom,scaleYRandom)
    }

    function finish(){
        if (gameOver == false){
            gameOver = true
            camera.fadeOut(6000)
        }
        
    }

    function update ()
    {

         // v2 Player runs on spot, and tween 

        // Player uses energy (auto via budget) to set velocity and coast on momentum, and to avoid incoming obstacles (budget/some stat determines auto dodge)

        // Enemies spawn and charge at intervals relating to a [month]

        // Player auto clears incoming obstacles provided they have enough energy (has a cost, identifiable visually), can use focus instead manually.  Challenge is balancing with monster chasing, requiring energy expenditure to avoid.  Obstacles cover the baseline outgoings per month, monster reps unexpected.  Remaining energy can be 'invested' (mechanics tbc) or is swept into savings each cycle -

        // enemy constantly eating a random amount of player energy (or at set intervals)
        // Income - budget = energy regen
        // As time passes, energy regen decreases by 4% (inflation) + x% (diffuclty ramp) per interval, and more enemies of higher chaos multipliers appear)
        // Enemy can sprint, rep unexpected cost, accelratin up to player (higher accelration = larger unexpected cost)  
        // Player can expend further energy to accelerate, and while sprinting cuts enemy accelration
        
        updateHighScore()

        player.setTint()
        
        if (player.flipX){
            sword.x = player.x - 10
            sword.y = player.y - 15
        } else {
            sword.x = player.x + 10
            sword.y = player.y - 15
        }



       
        if (distanceTravelled >= distanceToTravel){
            finish()
            
        }

        sword.body.checkCollision.none = true

        if (enemy1.flipX){
            eSword.x = enemy1.x + 25
            eSword.y = enemy1.y - 15
        } else {
            eSword.x = enemy1.x - 50
            eSword.y = enemy1.y - 15
        }

        eSword.body.checkCollision.none = true
       
        // playerVitals.x = camera.scrollX + (width * 0.1) //player.x + 25
        // playerVitals.y = camera.scrollY + (height * 0.015)//player.y - 20
        playerVitals.draw()

        // playerIcon.x = camera.scrollX + 25
        // playerIcon.y = camera.scrollY + 25

        enemy1Vitals.x = enemy1.x + 25
        enemy1Vitals.y = enemy1.y - 20
        enemy1Vitals.draw()

        playerProgress.x = camera.scrollX + width * 0.33
        playerProgress.y = camera.scrollY + (height * 0.85)
        playerProgress.draw()

        highScoreText.x = camera.scrollX + (width - 340)
        highScoreText.y = camera.scrollY + (height - 57)
        highScoreText.setText('High Score: ' + Math.floor(highScore))

        if(IS_TOUCH){
        left.x = camera.scrollX + (width * 0.1)// - 245 
        energy.x = camera.scrollX + (width * 0.9) 

        deadSpace.x = left.x + 40.5
        right.x = deadSpace.x + 40.5
        up.x = deadSpace.x
        down.x = deadSpace.x
        focusB.x = energy.x - 75

        left.y = camera.scrollY + (height - 85)
        energy.y = camera.scrollY + (height - 106)

        deadSpace.y = left.y
        right.y = deadSpace.y
        up.y = deadSpace.y - 40.5
        down.y = left.y + 40.5
        focusB.y = energy.y + 53
        }


        spotlight.x = player.x
        spotlight.y = player.y

       

        if (player.flipX){
            pSFX.x = player.x + 10
        } else {
            pSFX.x = player.x - 5
        }
        
        pSFX.y = player.y

        enemy1.y = height - 85

        console.log('Player is Hit: ' + playerIsHit)
        console.log('Enemy is Hit: ' + enemy1IsHit)
        console.log('Enemy Aggro: ' + enemy1Aggro)
        console.log('High Score: ' + highScore)
      
       
       //console.log('Enemy Chaos Factor: ' + chaosFactor)

      

        
        playerPosition = player.x
        
        playerSpeed = playerPosition / (width * 1.5)
        
        if (inBattle == false){
            this.woodsl2.tilePositionX += 1 * (playerSpeed)
            this.woodsl3.tilePositionX += 2 * (playerSpeed)
            this.woodsl4.tilePositionX += 4.5 * (playerSpeed)
            this.woodsl4.setAlpha(1) 
            camera.zoomTo(1,750)
            playerIcon.x = camera.scrollX + 25
            playerIcon.y = camera.scrollY + 25
            playerVitals.x = playerIcon.x + 30
            playerVitals.y = playerIcon.y - 20
        } else if (inBattle) {
            this.woodsl2.tilePositionX = camera.x * 0.3
            this.woodsl3.tilePositionX = camera.x * 0.6
            this.woodsl4.tilePositionX = camera.x
            this.woodsl4.setAlpha(0.9)
            camera.zoomTo(1.15,750)
            playerIcon.x = camera.scrollX + 65
            playerIcon.y = camera.scrollY + 45
            playerVitals.x = playerIcon.x + 30
            playerVitals.y = playerIcon.y - 20 
            text1.visible = false
            text2.visible = false
            text3.visible = false
            text4.visible = false
            text5.visible = false
            spendingBuffIcon.visible = true
            savingBuffIcon.visible = true
            investingBuffIcon.visible = true
            spendingBuffTierIcon.visible = true
            savingBuffTierIcon.visible = true
            investingBuffTierIcon.visible = true
        }

    
        
  

        chaosFactor = Phaser.Math.FloatBetween(chaosMultiplierMin,chaosMultiplierMax)
        enemy1.body.setSize(enemy1.width, enemy1.height)
        pSFX.setVisible(false)

        if (inBattle == false){

            player.flipX = false

            this.vines.body.checkCollision.none = false

            

            if (enemy1.x > width * 1.55 && player.x > width * 1.6){
                        enemy1.setVelocityX(-100)
            }

            enemy1.anims.play({key:'eRun',frameRate: 14 * playerSpeed},true);

            

            moveVines(this.vines, 4.5 * (playerSpeed))
            
            if (playerIsHit){ 
                player.anims.play({key:'pHurt',frameRate: 12},true); 
                player.on('animationcomplete', function () {
                    playerRecover();
                }, this);

            } else if (cursors.space.isDown && currentFocus > 0 && playerIsHit == false){
                this.vines.body.checkCollision.none = true

                distanceTravelled += 8

                playerVitals.decreaseFocus(maxEnergy / 150)

                player.anims.play({key:'pDash',frameRate: 12},true);

                if (player.flipX){
                        pSFX.x = player.x + 20
                    } else {
                        pSFX.x = player.x - 15
                    }
                pSFX.y = player.y - 25
                pSFX.setVisible(true)
                pSFX.setTint()
                pSFX.setAlpha(0.85)
                pSFX.setDepth(0)
                pSFX.play('chargeDash',true)

            
                player.body.maxVelocity.x = 300
                player.setVelocityX(200)
                
                
                //this.physics.moveTo(player,width * 1.8,height - 90,300)

        

                
            } 

            else if (Phaser.Input.Keyboard.JustDown(cursors.space)){
                
                
                player.setDragX(7500)

            
            } else if (cursors.down.isDown && currentEnergy > 0){

                this.vines.body.checkCollision.none = true
                
                
                
                playerVitals.decreaseEnergy(maxEnergy / 300)

                distanceTravelled += 4.5 * (playerSpeed)
            
                //if(Phaser.Input.Keyboard.JustDown(cursors.down)){
                    //player.chain([ {key:'pUptoFall',frameRate: 12},true, {key:'pSlide',frameRate: 6},true]);
                    player.anims.play({key:'pSlide',frameRate: 6},true);
                //}
                
                this.physics.moveTo(player,width * 1.4,height - 90,30)
            
            } else if (cursors.left.isDown && currentEnergy > 0 && currentFocus < maxFocus && playerIsHit == false){

                

                playerVitals.decreaseEnergy(maxEnergy / 900)
                playerVitals.decreaseFocus(-maxEnergy / 900)

                
                pSFX.setTint(0xf1c232)
                pSFX.setDepth(2)
                pSFX.setVisible(true)
                pSFX.play('chargeEnergy',true)
                if (spotlight.intensity < 1.25){
                    spotlight.intensity += 0.01
                }
                camera.shake(50, 0.0005);

                distanceTravelled += 4.5 * (playerSpeed)

                this.physics.moveTo(player,width * 1.4,height - 90,90)
                player.anims.play({key:'pRun',frameRate: 8},true);
                
            } else if (cursors.right.isDown && currentEnergy > 0 && playerIsHit == false){

                
                playerVitals.decreaseEnergy(maxEnergy / 600)
                this.physics.moveTo(player,width * 1.7,height - 90,90)
                player.anims.play({key:'pRun',frameRate: 16},true);
                

                distanceTravelled += 4.5 * (playerSpeed)
                    
                 
            } else if(playerIsHit == false) {

                player.body.checkCollision.none = false
                spotlight.intensity = 0.5

                distanceTravelled += 3

                playerVitals.decreaseEnergy(maxEnergy / 1500)
                this.physics.moveTo(player,width * 1.5,height - 90,150)
                player.anims.play({key:'pRun',frameRate: 12},true);
 

            }

        } else if (inBattle) {
            // In Battle Mode

            if (enemy1Alive == false){
                enemy1.x = 0
                enemy1.y =  0
                player.flipX = false
                
                inBattle = false
                e1MaxLife = budget * chaosFactor
                enemy1Life = e1MaxLife
                enemy1Vitals.p = 38 / e1MaxLife
                enemy1Alive = true
            }

            camera.startFollow(player, false, 0.05, 0.05)

            
            if(Math.abs(player.x - enemy1.x) <= 75){
                enemy1Aggro = true
            } else {
                enemy1Aggro = false
            }

           

            if (player.x - enemy1.x > 0){
                enemy1.flipX = true
            } else {
                enemy1.flipX = false
            }
             
            if (enemy1IsHit){
                enemy1.anims.play({key:'eHurt',frameRate: 12},true); 
                enemy1.on('animationcomplete', function () {
                    enemy1Recover();
                }, this);
            } else if (enemy1Alive && enemy1Life > 0 && enemy1IsHit == false) {
            
                if (enemy1Aggro && gameOver == false){
                    enemy1.anims.play({key:'eAttack'},true);
                    if (enemy1.anims.currentFrame.index >= 5 && enemy1.anims.currentFrame.index < 8){
                        eSword.body.checkCollision.none = false
                    }
                } else {
                    if(Math.abs(player.x - enemy1.x) > 75 && Math.abs(player.x - enemy1.x) <= 100){    
                    enemy1.anims.play({key:'eIdle',frameRate: 10},true);
                    } else if (gameOver == false){
                        this.physics.moveToObject(enemy1,player,200)
                        enemy1.anims.play({key:'eRun',frameRate: 14},true);
                    } else if (gameOver){
                        enemy1.anims.play({key:'eIdle',frameRate: 10},true);
                    }
                }
                
                    
                 
          
    
            } else if (enemy1Life <= 0 && enemy1Alive){
                 
                enemy1.anims.play({key:'eDeath'},true);
                
                
                if (enemy1.anims.currentFrame.index > 9){
                enemy1Alive = false
                }
                    
            }

     

            player.body.setSize(10, 30).setOffset(25,15)

           if(player.body.onFloor()){
            
                player.setDragX(600)
            
            
            } else {
                player.setDragX(100)
            }
           
            enemy1.setDragX(600)
            
           
            
            
            
            if (currentLife <= 0 && gameOver == false){
                player.anims.play({key:'pDeath',frameRate: 12},true); 
                player.on('animationcomplete', function () {
                    finish();
                 }, this);
            } else if (currentLife >= 0 && gameOver == false){
                if (playerIsHit){

                player.anims.play({key:'pHurt',frameRate: 12},true); 
                player.on('animationcomplete', function () {
                playerRecover();
                }, this);
                } else if (cursors.up.isDown && cursors.space.isDown && currentFocus > 0 && currentEnergy < maxEnergy * 0.99){   
            
            player.anims.play({key:'pChargeEnergy'},true);
            pSFX.setVisible(true)
            pSFX.setDepth(1)
            pSFX.setTint(0x93c47d)
            pSFX.play('chargeEnergy',true)
            if (spotlight.intensity < 1.5){
            spotlight.intensity += 0.02
            }
            camera.shake(50, 0.0005);


            playerVitals.decreaseFocus(maxFocus / 600)
            playerVitals.decreaseEnergy(-maxFocus / 600)


            } else if ((cursors.left.isDown && keyA.isDown || cursors.right.isDown && keyA.isDown) && currentEnergy > 0){
            
            player.anims.play({key:'pHeavyAttack',frameRate: 12},true);

            
            playerVitals.decreaseEnergy(maxEnergy / 300)
            damage = maxEnergy * 0.75

            // Activate Sword Hitbox

            if (player.anims.currentFrame.index >= 4 && player.anims.currentFrame.index < 6){
            sword.body.checkCollision.none = false
            } 

            } else if (keyA.isDown && currentEnergy > 0 && cursors.up.isUp){
            
            if(Phaser.Input.Keyboard.JustDown(keyA)){
                player.anims.play({key:'pChargeAttack'},true);
            }
            
            if (spotlight.intensity < 1.25){
                spotlight.intensity += 0.01
            }
            
            
            if (chargePower <= 1.1){
                chargePower += 0.025
            }

            damage = maxEnergy * 0.5 * chargePower

            keyDuration = keyA.getDuration()
            if (chargePower < 0.95){
                playerVitals.decreaseEnergy(maxEnergy / 300)
            } else {
                playerVitals.decreaseEnergy(maxEnergy / 600)
            }
            

            
            }  else if (keyA.isUp && keyDuration > 0 && cursors.space.isUp){

            if (player.anims.currentFrame.index >= 6 && player.anims.currentFrame.index < 12){
                    sword.body.checkCollision.none = false
            }

            spotlight.setIntensity(0.5)

            

            if (chargePower > 0.75){

                player.anims.play({key:'pAttack',frameRate: 24, startFrame: 3, repeat: 1},true);
                    
            } else if (chargePower >= 0.25 && chargePower < 0.75){
                player.anims.play({key:'pAttack',frameRate: 16, startFrame: 3},true);
            } else if (chargePower <  0.25){
                player.anims.play({key:'pQuickAttack',frameRate: 18, startFrame: 3, endFrame: 8},true);
            }

            player.on('animationcomplete', function () {    
            playerComboEnd();
            }, this);


            } else if (cursors.space.isDown && currentFocus > 0 && cursors.up.isUp){

            if (spotlight.intensity < 1.25){
                spotlight.intensity += 0.01
            }
            
            
            if (chargePower <= 1.1){
                chargePower += 0.025
            }

            if (chargePower < 0.15){
                chargePower = 0.15
            } 

            if(Phaser.Input.Keyboard.JustDown(cursors.space)){
            player.anims.play({key:'pChargeDash'},true);
            
            }
            pSFX.setVisible(true)

            if (player.flipX){
                pSFX.x = player.x + 20
            } else {
                pSFX.x = player.x - 15
            }
            pSFX.y = player.y - 25
            pSFX.setTint()
            pSFX.setAlpha(0.85)
            pSFX.setDepth(0)
            pSFX.play('chargeDash',true)

            playerVitals.decreaseFocus(maxFocus / 400)

            keyFocusDuration = cursors.space.getDuration()

            

            } 

            else if (Phaser.Input.Keyboard.JustDown(cursors.space)){

            player.setDragX(5000)

            } else if (cursors.space.isUp && keyFocusDuration > 0){


            spotlight.setIntensity(0.5)

            player.anims.play({key:'pDash',frameRate: 12},true);

            
            if (player.flipX){
                
                player.body.maxVelocity.x = 750
                this.physics.moveTo(player,player.x - 100,height - 90,750 * chargePower)

            } else if (player.flipX == false) {

                
                player.body.maxVelocity.x = 750
                this.physics.moveTo(player,player.x + 100,height - 90,750 * chargePower)
                
            }

            player.on('animationcomplete', function () {    
            playerComboEnd();
            }, this);


            } 

            else if (cursors.down.isDown && player.body.touching.down){ 
            
            if(Phaser.Input.Keyboard.JustDown(cursors.down)){
            //player.chain([ {key:'pUptoFall',frameRate: 12},true, {key:'pSlide',frameRate: 6},true]);
            player.anims.play({key:'pSlide',frameRate: 12},true);
            }
            
            player.setDragX(300)
                    
            } 

            else if (cursors.left.isDown && player.body.touching.down){

            player.setVelocityX(player.body.velocity.x - (20 * devicePixelRatio))
            player.flipX = true 
            player.anims.play({key:'pRun',frameRate: 10},true);
            
            
            } 

            else if (cursors.right.isDown && player.body.touching.down){

            player.setVelocityX(player.body.velocity.x + (20 * devicePixelRatio))
            player.flipX = false
            player.anims.play({key:'pRun',frameRate: 10},true);

            }  

            else if (player.body.touching.down){

            player.anims.play({key:'pIdle',frameRate: 8},true);
            player.body.maxVelocity.x = 250
            
            spotlight.setIntensity(0.5)


            } 

            else {
            player.anims.play({key:'pUptoFall',frameRate: 8});
            player.body.maxVelocity.x = 250
            
            spotlight.setIntensity(0.5)
            }
            } 

            } 

        }

    
            

        
       
    


</script>

</body>
</html>
