<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 1</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    var ratio = Math.max(window.innerWidth / window.innerHeight, window.innerHeight / window.innerWidth)
    var DEFAULT_HEIGHT = 272  // any height you want
    var DEFAULT_WIDTH = ratio * DEFAULT_HEIGHT// * 2

    var config = {
        type: Phaser.AUTO,

        scale: {

            parent: 'mygame',
            mode: Phaser.Scale.FIT,
            width:  DEFAULT_WIDTH, //592, //window.innerWidth * window.devicePixelRatio
            height: DEFAULT_HEIGHT //272, //window.innerHeight * window.devicePixelRatio
        },
        input: {
            keyboard: true,
            gamepad: true
        },
        physics:{
            default:'arcade',
            arcade:{
                gravity:{x: 0, y:350},
                debug: 0,
                overlapBias: 20
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };


    var game = new Phaser.Game(config);
    var gameOver = false

    

    var width = game.config.width
    var height = game.config.height
    var spotlight
    var section 
 
    var startPosition 
    var playerPosition 
    var enemyPosition

    var tweenLeft
    var tweenRight
    var tweenUp
    

    var enemyGroup
 
    var playerSpeed 
    var slowMo                                          
    var deathBlows = false
    var parry = false

    var startLife = 300
    var currentEnergy = 50
    var currentEnergyText
    var maxEnergy = 100
    var startMaxEnergy = 100
    var currentFocus = 50
    var maxFocus = maxEnergy * 3
    var income = 100
    var budget = 60
    var energyRegen = income - budget
    var power
    var budgetRatio = budget/income
    var budgetAccuracy = 0.9
    var chaosMultiplierMin = 0.7
    var chaosMultiplierMax = 2.5
    var maxLife = maxEnergy * 3
    var currentLife

    var pad1
    
 

    class HealthBar {

        constructor (scene,startLife, x, y)
        {
            this.bg = new Phaser.GameObjects.Graphics(scene).setDepth(1);
            
            this.lifeBar = new Phaser.GameObjects.Graphics(scene).setDepth(1);
            this.energyBar = new Phaser.GameObjects.Graphics(scene).setDepth(1);
            this.focusBar = new Phaser.GameObjects.Graphics(scene).setDepth(1);

            this.x = x;
            this.y = y;
            
            this.pL =  38 / maxLife
            this.pE =  38 / maxEnergy
            this.pF =  38 / maxFocus 

            this.draw();

            scene.add.existing(this.bg)
            scene.add.existing(this.lifeBar);
            scene.add.existing(this.energyBar);
            scene.add.existing(this.focusBar);
        }

        decreaseLife (amount)
        {
            currentLife -= amount;

            if (currentLife < 0)
            {
                currentLife = 0;
            }

            this.draw();

            return (currentLife === 0);
        }

        decreaseEnergy (amount)
        {
            currentEnergy -= amount;

            if (currentEnergy < 0)
            {
                currentEnergy = 0;
            }

            this.draw();

            return (currentEnergy === 0);
        }

        decreaseFocus (amount)
        {
            currentFocus -= amount;

            if (currentFocus < 0)
            {
                currentFocus = 0;
            }

            this.draw();

            return (currentFocus === 0);
        }

        draw ()
        {
            this.bg.clear()
            this.lifeBar.clear();
            this.energyBar.clear();
            this.focusBar.clear();

            //  BG
            this.bg.fillStyle(0x000000);
            this.bg.fillRect(this.x, this.y, 40, 13);

            //  Health

            this.lifeBar.fillStyle(0xffffff);
            this.lifeBar.fillRect(this.x + 1, this.y + 1, 38, 3);
            this.lifeBar.fillStyle(0xcc0000);


            var d = Math.floor(this.pL * currentLife);

            this.lifeBar.fillRect(this.x + 1, this.y + 1, d, 3);

            //  Energy

            this.energyBar.fillStyle(0xffffff);
            this.energyBar.fillRect(this.x + 1, this.y + 5, 38 * (maxEnergy/startMaxEnergy) , 3);
            this.energyBar.fillStyle(0x93c47d);
        

            var d = Math.floor(this.pE * currentEnergy);

            this.energyBar.fillRect(this.x + 1, this.y + 5, d, 3);

            //  Focus

            this.focusBar.fillStyle(0xffffff);
            this.focusBar.fillRect(this.x + 1, this.y + 9, 38, 3);
            this.focusBar.fillStyle(0xf1c232);
            

            var d = Math.floor(this.pF * currentFocus);

            this.focusBar.fillRect(this.x + 1, this.y + 9, d, 3);
        }

    }
       
   

    function grabbed(){
       
                player.setTint(0xe06666)
                if (currentLife / maxLife > 0.30){
                playerVitals.decreaseEnergy(currentEnergy * 0.025)
                playerVitals.decreaseLife(currentLife * 0.05)
                playerVitals.decreaseFocus(currentFocus * 0.2)
                
                player.body.maxVelocity.x -= Phaser.Math.Between(30, 15)
                maxEnergy *= 1 - 0.04
                income *= 1 - 0.04

                player.setVelocity(Math.max(15,player.body.velocity.x - 20))
                enemy.setVelocityX(Phaser.Math.Between(-150, -75))
                player.setVelocityX(Phaser.Math.Between(-25, 5))
                } else {
        
                 deathBlows = true
            
            }


        }
       

    // 144 seconds = 1 year
    // 12 seconds = 1 month
    // 3 second per week

//     function runCycleFunctions()
//     {
//        if (deathBlows == false && gameOver == false){
//         var totalEnergy = currentEnergy + energyRegen
//         currentEnergy = Phaser.Math.MaxAdd(currentEnergy, energyRegen,maxEnergy) 
//         currentFocus = Phaser.Math.MaxAdd(currentFocus,totalEnergy - currentEnergy,maxFocus)
//         player.body.maxVelocity.x += currentFocus / maxEnergy
//         player.body.maxVelocity.x *= 1 - (0.04 / 12)   
//         player.setVelocity(player.body.velocity.x + (player.body.maxVelocity.x  * budgetRatio * power)) 
//         //maxEnergy *= 1 - (0.04 / 12)
//         income *= 1 - (0.04 / 12)
//         budget *= 1 - (0.04 / 12)
//         // if(enemyPosition > width * 2.2){
//         //     enemy.setVelocity(Math.abs(enemy.body.velocity.x) + Phaser.Math.Between(-50, -10))
//         // }  else {
//         //     enemy.setVelocity(Math.abs(enemy.body.velocity.x) + (enemy.body.maxVelocity.x  * (Phaser.Math.Between(chaosMultiplierMin, chaosMultiplierMax) - 1 ))) 
//         // }

//         chaosMultiplierMin *= 1.02
//         chaosMultiplierMax *= 1.04
        
        
//     }
// }

    function runCycle2Functions()
    {
        // spawn('doomsayer');
    }

    
  
    


    function preload ()
    {
        this.load.image('dawnl1', 'assets/dawn1.png');
        this.load.image('dawnl2', 'assets/dawn2.png');
        this.load.image('dawnl3', 'assets/dawn3.png');
        this.load.image('dawnl4', 'assets/dawn4.png');
        this.load.image('dawnl5', 'assets/dawn5.png');
        this.load.image('dawnl6', 'assets/dawn6.png');
        this.load.image('dawnl7', 'assets/dawn7.png');
        this.load.image('dawnl8', 'assets/dawn8.png');
        this.load.image('woodsl1', 'assets/woods1.png');
        this.load.image('woodsl2', 'assets/woods2.png');
        this.load.image('woodsl3', 'assets/woods3.png');
        this.load.image('woodsl4', 'assets/woods4.png');
        this.load.image('ground', 'assets/woodground.png');
        this.load.atlas('logan', 'assets/loganv2.png','assets/loganspritesv2.json');
        this.load.atlas('doomsayer', 'assets/doomsayer.png','assets/doomsayersprites.json');
        this.load.atlas('heroF', 'assets/heroF.png','assets/heroF.json');
        this.load.atlas('heroM', 'assets/heroM.png','assets/heroM.json');
  

    }

    function create ()
    {


        



        startPosition = width - 10

        this.physics.world.setBounds(0, 0, width * 3,  height);
        
        this.woodsl1 = this.add.tileSprite(0,0, width * 3, height, 'woodsl1').setOrigin(0,0).setScrollFactor(0)//.setPipeline('Light2D')
        this.woodsl2 = this.add.tileSprite(0,0, width * 3, height, 'woodsl2').setOrigin(0,0).setScrollFactor(0.25)//.setPipeline('Light2D')
        this.woodsl3 = this.add.tileSprite(0,0, width * 3, height, 'woodsl3').setOrigin(0,0).setScrollFactor(0.5)//.setPipeline('Light2D')
        this.woodsl4 = this.add.tileSprite(0,0, width * 3, height, 'woodsl4').setOrigin(0,0).setScrollFactor(1).setDepth(1)//.setPipeline('Light2D')

        
        this.lights.enable();
        this.lights.setAmbientColor(0x808080);

        spotlight = this.lights.addLight(400, 300, 280).setIntensity(0.75);
        spotlight2 = this.lights.addLight(400, 300, 280).setIntensity(0.25);
       
        platforms = this.physics.add.staticGroup();
        platforms.create(0, height - 50, 'ground').setOrigin(0,0).setScale(width * 3 /400).refreshBody().setVisible(0);

        spawn = (enemyName) => {
            enemy = this.physics.add.sprite(Phaser.Math.Between(0,50), height - 85, enemyName).setScale(1.75).setPipeline('Light2D');;
            enemy.setDepth(0)
            enemy.flipX = true
            enemy.body.maxVelocity.x = 100
            enemy.setBounceY(0.15);
            enemy.setCollideWorldBounds(true)
            this.physics.add.overlap(enemy, player, grabbed);
            this.physics.add.collider(player,enemy);
            this.physics.add.collider(platforms,enemy);
            enemy.anims.play({key:'eRun',frameRate: 10},true);
            enemy.body.setAllowDrag(true)
            
            enemy.setVelocity(Math.abs(player.body.velocity.x) + (player.body.maxVelocity.x  * (Phaser.Math.Between(chaosMultiplierMin, chaosMultiplierMax) - 1 ))) 
        }

        player = this.physics.add.sprite(startPosition + 25, height - 90 ,'heroF').setScale(2.5).setPipeline('Light2D');
        player.tint = 0xdd7e6b;
        currentLife = startLife
        playerVitals = new HealthBar(this,startLife, player.x, player.y - 50);


        camera = this.cameras.main.startFollow(player, false, 0.05, 0.05)

        camera.setBounds(0, 0, width * 2.9, height)
        camera.fadeIn(6000)


        
        player.body.maxVelocity.x = 30
        player.body.setSize(20, 30).setOffset(15,15).setAllowDrag(true)
        player.setBounceY(0.15);
        player.setCollideWorldBounds(true);
        player.setVelocityX(player.body.maxVelocity.x * (currentEnergy / maxEnergy))

        // spawn('doomsayer');
        
        this.physics.add.collider(player,platforms);
        

        // cycle1Timer = this.time.addEvent({delay: 12000, callback: runCycleFunctions, args: [], callbackScope: this, loop: true});
        // cycle2Timer = this.time.addEvent({delay: 144000, callback: runCycle2Functions, args: [], callbackScope: this, loop: true});

       tweenLeft = this.tweens.add({targets: player, x: (width * 1.25),ease: 'Phaser.Easing.Cubic.In', duration: 1500})

        this.anims.create({
            key: 'pIdle',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Idle_', start: 1, end: 6, suffix: '.png'}),
            frameRate: 6,
            repeat: -1
        });

       

        this.anims.create({
            key: 'pDeath',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Death_', start: 1, end: 11, suffix: '.png'}),
            frameRate: 12,
            repeat: 0
        });

       

        this.anims.create({
            key: 'pHurt',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_hurt_', start: 1, end: 4, suffix: '.png'}),
            frameRate: 4,
            repeat: 0
        });

        this.anims.create({
            key: 'pSlide',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior-Slide_', start: 1, end: 5, suffix: '.png'}),
            frameRate: 14,
            repeat: 0
        });

        this.anims.create({
            key: 'pJump',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Jump_', start: 1, end: 3, suffix: '.png'}),
            frameRate: 12,
            repeat: 0
        });

        this.anims.create({
            key: 'pUptoFall',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_UptoFall_', start: 1, end: 2, suffix: '.png'}),
            frameRate: 10,
            repeat: 0
        });


       

        this.anims.create({
            key: 'pRun',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Run_', start: 1, end: 8, suffix: '.png'}),
            frameRate: 14,
            repeat: 0,
            //delay: 1
        });

        this.anims.create({
            key: 'pDash',
            frames: this.anims.generateFrameNames('heroF',{prefix: 'Warrior_Dash_', start: 1, end: 7, suffix: '.png'}),
            frameRate: 14,
            repeat: 0,
            //delay: 1
        });

        // this.anims.create({
        //     key: 'p2Hurt',
        //     frames: this.anims.generateFrameNames('heroM',{prefix: 'adventurer-die-0', start: 0, end: 2, suffix: '.png'}),
        //     frameRate: 3,
        //     repeat: 0
        // });

        //  this.anims.create({
        //     key: 'p2Death',
        //     frames: this.anims.generateFrameNames('heroM',{prefix: 'adventurer-die-0', start: 0, end: 6, suffix: '.png'}),
        //     frameRate: 12,
        //     repeat: 0
        // });

        //   this.anims.create({
        //     key: 'p2Idle',
        //     frames: this.anims.generateFrameNames('heroM',{prefix: 'adventurer-idle-2-0', start: 0, end: 3, suffix: '.png'}),
        //     frameRate: 3,
        //     repeat: -1
        // });



        this.anims.create({
            key: 'p2Run',
            frames: this.anims.generateFrameNames('heroM',{prefix: 'adventurer-run3-0', start: 0, end: 5, suffix: '.png'}),
            frameRate: 12,
            repeat: -1
        });

        this.anims.create({
            key: 'p2Jump',
            frames: this.anims.generateFrameNames('heroM',{prefix: 'adventurer-jump-0', start: 0, end: 3, suffix: '.png'}),
            frameRate: 12,
            repeat: 0
        });

    

       

        this.anims.create({
            key: 'eIdle',
            frames: this.anims.generateFrameNames('doomsayer',{prefix: 'idle', start: 1, end: 8}),
            frameRate: 10,
            repeat: -1
        });

       
        this.anims.create({
            key: 'eRun',
            frames: this.anims.generateFrameNames('doomsayer',{prefix: 'walk', start: 1, end: 8}),
            frameRate: 10,
            repeat: 0
        });


        this.anims.create({
            key: 'eAttack',
            frames: this.anims.generateFrameNames('doomsayer',{prefix: 'attack', start: 1, end: 10}),
            frameRate: 10,
            repeat: 2,
            repeatDelay: 1000,
            delay:  Math.random() * 500
            
        });

        // this.anims.create({
        //     key: 'eHurt',
        //     frames: this.anims.generateFrameNames('doomsayer',{prefix: 'hurt', start: 1, end: 3}),
        //     frameRate: 10,
        //     repeat: 0
        // });

        // this.anims.create({
        //     key: 'eDeath',
        //     frames: this.anims.generateFrameNames('doomsayer',{prefix: 'hurt', start: 1, end: 10}),
        //     frameRate: 10,
        //     repeat: 0
        // });

        
      

        // Controllers online
        cursors = this.input.keyboard.createCursorKeys();

      

        


    }

    function update ()
    {

        // enemy constantly eating a random amount of player energy (or at set intervals)
        // Income - budget = energy regen
        // As time passes, energy regen decreases by 4% (inflation) + x% (diffuclty ramp) per interval, and more enemies of higher chaos multipliers appear)
        // Enemy can sprint, rep unexpected cost, accelratin up to player (higher accelration = larger unexpected cost)  
        // Player can expend further energy to accelerate, and while sprinting cuts enemy accelration

        player.setTint()
        playerVitals.x = player.x + 25
        playerVitals.y = player.y - 20
        playerVitals.draw()

        spotlight.x = player.x
        spotlight.y = player.y

        // spotlight2.x = enemy.x
        // spotlight2.y = enemy.y
        

        
        console.log('Section: ' + section)
        console.log('Drag Strength: ' + Math.round(((playerPosition - (width *2))/width) * 100))
        console.log('Player X Position : ' + Math.round(playerPosition))
        // console.log('Player Velocity: ' + Math.round(player.body.velocity.x))
        // console.log('Player Acceleration: ' + Math.round(player.body.acceleration.x))
        // console.log('Chaos Min - Max: ' + chaosMultiplierMin + ' - ' + chaosMultiplierMax)
        //console.log(Math.round(player.body.maxVelocity.x))          
        // console.log(Math.round(enemy.body.velocity.x))
        
        
        
        playerPosition = player.body.position.x
        // enemyPosition = enemy.body.position.x

        section = Math.round((playerPosition + (width / 2)) / width) 
        power = currentEnergy/maxEnergy

        if (slowMo == true){
                playerSpeed = 0.5 + (playerPosition / (width * 3)) * 0.25
            } else  if (deathBlows == true){
                playerSpeed = 0
            } else {
                playerSpeed = 0.5 + (playerPosition / (width * 3))
        
        }
        
        this.woodsl2.tilePositionX += 1.5 * (playerSpeed)
        this.woodsl3.tilePositionX += 3 * (playerSpeed)
        this.woodsl4.tilePositionX += 6 * (playerSpeed) 
        

        // v2 Player runs on spot, and tween 

        // Player uses energy (auto via budget) to set velocity and coast on momentum, and to avoid incoming obstacles (budget/some stat determines auto slowMo/dodge)

        // Enemies spawn and charge at intervals relating to a [month]

        // Player auto clears incoming obstacles provided they have enough energy (has a cost, identifiable visually), can use focus instead manually.  Challenge is balancing with monster chasing, requiring energy expenditure to avoid.  Obstacles cover the baseline outgoings per month, monster reps unexpected.  Remaining energy can be 'invested' (mechanics tbc) or is swept into savings each cycle - 

        // var running = true

        // if (running){
        //     // Functions to run when player is running

        //     // Listener events, when action button pressed

        //     // Jumping

        //     if (cursors.up.isDown && player.body.touching.down){
               
        //         player.anims.play({key:'p2Jump',frameRate: 4}, true);
                
        //         player.setVelocityY(player.body.velocity.y - 6)
        //         player.setVelocityX(player.body.velocity.x + 3)
        //     // Sprinting
        //     } else if (cursors.right.isDown){
        //         player.anims.play({key:'p2Run',frameRate: 10},true);
        //     // Sliding
        //     } else if (cursors.down.isDown){

        //     }   else if (cursors.left.isDown) {

        //     }  else if (cursors.space.isDown){

        //     } else if (player.body.touching.down) {
        //        player.anims.play({key:'p2Run',frameRate: 10},true); 
        //     } else {
        //         // Falling
        //     }             
        // }


        // if (slowMo == false && deathBlows ==false){

        //     if (playerPosition >= width * 3){
        //         player.setVelocityX(-75)
        //     } else 

        //     if (section == 3){
        //         player.setAccelerationX(-100 * ((playerPosition - (width *2))/width))
        //         if (player.body.touching.down){
        //             player.anims.play({key:'pRun',frameRate: 18},true);
        //         }
                
        //         // enemy.anims.play({key:'eRun',frameRate: 14},true);
        //     } else if (section == 2) {
        //         player.setAccelerationX(Phaser.Math.Between(-5,6) * ((playerPosition - width)/width))
        //         if (player.body.touching.down){
        //         player.anims.play('pRun',true);
        //     }
        //         // enemy.anims.play({key:'eRun',frameRate: 12},true);
        //     } else {
        //         player.setAccelerationX(0)
        //         if (player.body.touching.down){
        //         player.anims.play({key:'pRun',frameRate: 10},true);
        //     }
        //         // enemy.anims.play({key:'eRun',frameRate: 10},true);
            
        //     }

        // }

        player.anims.play('pRun',true);

        if (cursors.left.isDown){
            tweenLeft.play()
        } else

        if (cursors.up.isDown  && currentEnergy > 35 && deathBlows == false){
            camera.zoomTo(1.25, 2000);
            slowMo = true
            player.flipX = false
            currentEnergy -=  income * (16 / 2500)

            //player.anims.play({key:'pJump',frameRate: 4},true);
            player.chain([ {key:'pJump',frameRate: 4},true, {key:'pUptoFall',frameRate: 4},true]);
            player.setVelocityY(player.body.velocity.y - 7)  
            player.setAccelerationX(-10)
            enemy.setVelocityX(enemy.body.velocity.x - 2)
            enemy.setAccelerationX(0)

            enemy.anims.play({key:'eRun',frameRate: 4},true);

        } else 
        if (cursors.down.isDown && currentEnergy > 15 && deathBlows == false){
            camera.zoomTo(1.5, 1500);
            slowMo = true
            player.flipX = false
            currentEnergy -=  income * (8 / 2500)

            player.setAccelerationX(-5)
            enemy.setVelocityX(enemy.body.velocity.x - 2)
            enemy.setAccelerationX(0)

            player.anims.play({key:'pSlide',frameRate: 4});
            // enemy.anims.play({key:'eRun',frameRate: 4},true);
        } else

        if (cursors.space.isDown && currentFocus > 0 && deathBlows == false)
        {

            //camera.pan(player.x, player.y, 2000, 'Power2');
            
            
            currentFocus -=  income * (16 / 2500)
            currentEnergy -=  income * (2 / 2500)
            slowMo = true
            player.flipX = false
            player.x += 1
            player.setVelocityX(50)
            enemy.setVelocityX(enemy.body.velocity.x - 2)
            enemy.setAccelerationX(0)

            //player.chain([{key:'pRun',frameRate: 4, repeat: 0}, {key:'pDash',frameRate: 4}]);
            player.anims.play({key:'pDash',frameRate: 4},true);
            // enemy.anims.play({key:'eRun',frameRate: 4},true);
    

        } else if (deathBlows == true && gameOver == false){  


            player.anims.play('pIdle',true);
            player.flipX = true
            player.setAccelerationX(0)
            player.setVelocityX(0)
            enemy.setVelocity(0) 
            enemy.setAccelerationX(0)

            enemy.disableBody()
            enemy.anims.play('eAttack', true);

            if (enemy.anims.currentFrame.index >= 4 && enemy.anims.currentFrame.index < 6 && cursors.space.isDown){
                player.setTint(0x93c47d)
                parry = true
                currentEnergy += Math.min(maxEnergy - currentEnergy, maxEnergy * 0.5)
            } else if ((enemy.anims.currentFrame.index < 4 || enemy.anims.currentFrame.index >= 5) && cursors.space.isDown){
                parry = false
            }

            if (enemy.anims.currentFrame.index == 5 && parry == false){
               //camera.shake(100);
               currentFocus -= currentFocus * 0.16
               playerVitals.decreaseLife(Phaser.Math.Between(maxLife * 0.01, maxLife * 0.02))
               
               
                   if (currentLife > 0){
                
                    currentEnergy -= Math.min(currentEnergy,maxEnergy * 0.16)   
                    player.setTint(0xcc4125)
                    } else {
                    camera.shake(500);
                    player.setTint(0xe06666)
                    player.anims.play('pDeath',true)
                    //player.disableBody(false,false)

                    enemy.anims.play('eIdle', true)
                    gameOver = true 
                    camera.fadeOut(6000)
                    }
                    
            }  else if (enemy.anims.currentFrame.index >= 5  && enemy.anims.currentFrame.index <= 8 && parry == false) {

                player.anims.play('pHurt',true)
                
            } else if (enemy.anims.currentFrame.index >= 9) {
                player.setTint()
                parry = false
                if (currentEnergy / maxEnergy > 0.3) {
                    deathBlows = false
                    player.flipX = false
                    enemy.enableBody()
                    player.setAccelerationX(0)
                    player.setVelocityX(25)
                    enemy.setVelocity(-100) 
                    enemy.setAccelerationX(0)

                } 
            }

        } else if (gameOver == false) {
                
            slowMo = false
            flag = false
            camera.zoomTo(1, 250);
        }
                
    }


</script>

</body>
</html>